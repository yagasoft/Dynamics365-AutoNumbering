// This file isn't generated, but this comment is necessary to exclude it from StyleCop analysis.
// Author: Ahmed Elsawalhy (Yagasoft.com)
// Version: 4.4.3
// <auto-generated />

#region Imports

using System;
using System.Activities;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Reflection;
using System.Runtime.Caching;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization.Json;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.Crm.Sdk.Messages;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Client;
using Microsoft.Xrm.Sdk.Messages;
using Microsoft.Xrm.Sdk.Metadata;
using Microsoft.Xrm.Sdk.Metadata.Query;
using Microsoft.Xrm.Sdk.Query;
using Microsoft.Xrm.Sdk.Workflow;
using Match = System.Text.RegularExpressions.Match;
using RelationshipType = Microsoft.Xrm.Sdk.Metadata.RelationshipType;

#endregion

namespace Yagasoft.Libraries.Common
{

	#region Enums

	/// <summary>
	///     The log levels
	/// </summary>
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public enum LogLevel
	{
		None = 0,
		Error = 10,
		Warning = 20,
		Info = 30,
		Debug = 40
	}

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public enum LogMode
	{
		Crm = 10,
		File = 20,
		Both = 30
	}

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public enum SplitMode
	{
		Size = 10,
		Date = 20,
		Both = 30
	}

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public enum SplitFrequency
	{
		Hourly = 10,
		Daily = 20,
		Monthly = 30,
		Yearly = 40
	}

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public enum PluginUser
	{
		ContextUser,
		InitiatingUser,
		System,
		Custom
	}

	#endregion

	#region Extensions

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class Extensions
	{
		private const string StringExceptionMsg = "String value cannot be empty.";
		private const string DefaultStringFormatExceptionMsg = "String format is invalid.";
		private const string DefaultNullExceptionMessage = "Value cannot be null.";
		private const string DefaultRangeMessage = "Parameter value out of range.";
		private const string DefaultArrayMemberMessage = "Array member can't be null.";
		private const string DefaultParameterName = "Unknown";
		private const string RegexEscapes = @"[\a\b\f\n\r\t\v\\""]";

		/// <summary>
		/// Return the distinct values of the source collection using the key returned by a selector function.<br />
		/// Credit: https://stackoverflow.com/a/24823445/1919456<br />
		/// </summary>
		public static IEnumerable<TSource> DistinctBy<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			var set = new HashSet<TResult>();

			foreach (var item in source)
			{
				var selectedValue = selector(item);

				if (set.Add(selectedValue))
				{
					yield return item;
				}
			}
		}

		#region Dates

		public static DateTime ConvertToCrmUserTimeZone(this DateTime dateTime, IOrganizationService service, Guid userId)
		{
			var bias = CrmHelpers.GetUserTimeZoneBiasMinutes(service, userId);
			var biasedDate = dateTime.AddMinutes(bias);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Local);
		}

		public static DateTime ConvertToCrmUtcTimeZone(this DateTime dateTime, IOrganizationService service, Guid userId)
		{
			var bias = CrmHelpers.GetUserTimeZoneBiasMinutes(service, userId);
			var biasedDate = dateTime.AddMinutes(-bias);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Utc);
		}

		public static DateTime ConvertBetweenCrmUsersTimeZone(this DateTime dateTime, IOrganizationService service,
			Guid user1Id, Guid user2Id)
		{
			var biases = CrmHelpers.GetUsersTimeZoneBiasMinutes(service, user1Id, user2Id);
			var bias1 = biases[user1Id];
			var bias2 = biases[user2Id];

			var biasedDate = dateTime.AddMinutes(-bias1).AddMinutes(bias2);

			return DateTime.SpecifyKind(biasedDate, DateTimeKind.Local);
		}

		#endregion

		// Credit: http://www.codeproject.com/Articles/290695/Extension-methods-to-simplify-null-argument-check

		#region Param checks

		#region NULL CHECK FOR OBJECT OF ANY CLASS

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if target object is null.
		///     The method is constrained to objects of class type. The method is intended to be used
		///     for null parameter check.
		/// </summary>
		/// <typeparam name="T">Type of parameter</typeparam>
		/// <param name="obj">Target object of type T</param>
		/// <param name="paramName">
		///     Name of the parameter.If paramName name is null empty or whitespace default value will be
		///     paramNmae = "Unknown".
		/// </param>
		/// <param name="message">Exception message.If not provided default value is "Value can not be null."</param>
		public static void Require<T>(this T obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : class
		{
			if (obj == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		#endregion NULL CHECK FOR OBJECT OF ANY CLASS

		#region NULL CHECK FOR OBJECT OF NULLABLE TYPE

		/// <summary>
		///     Generic extension method that throws ArgumentNullException if type value is null.
		///     The method is constrained to objects of Nullable struct type. The method is intended to be used
		///     for null parameter check.
		/// </summary>
		/// <typeparam name="T">Type of target object</typeparam>
		/// <param name="obj">Target object of type T.</param>
		/// <param name="paramName">
		///     Name of the parameter.if pramName is null empty or whitespace default paramName = "Unknown"
		///     will be used.
		/// </param>
		/// <param name="message">Exception message.If not provoided default value is "Value can not be null."</param>
		public static void Require<T>(this T? obj, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
			where T : struct
		{
			if (obj == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		#endregion NULL CHECK FOR OBJECT OF NULLABLE TYPE

		#region NULL CHECK FOR OBJECT ARRAY

		/// <summary>
		///     Method throws ArgumentNullException if any of object reference in array is null.
		///     Note : Using value types in array may result in unnecessary boxing.
		///     Use only when you do not care about message , parameter name and empty/whitespace string.
		///     Certainly not enough for production quality code.
		/// </summary>
		/// <param name="value">Object array containing target object references.</param>
		/// <param name="paramName"></param>
		/// <param name="message"></param>
		public static void Require(this object[] value, string paramName = DefaultParameterName,
			string message = DefaultArrayMemberMessage)
		{
			if (value == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (value.Any(param => param == null))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		public static void RequireCountBelow<T>(this T collection, int max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count >= max)
			{
				message = $@"Collection count must be less than ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		public static void RequireCountAtMost<T>(this T collection, int max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count > max)
			{
				message = string.Format(@"Collection count must be less than or equal to ""{0}"".", max);
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		public static void RequireCountAbove<T>(this T collection, int min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count <= min)
			{
				message = $@"Collection count must be greater than ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		public static void RequireCountAtLeast<T>(this T collection, int min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count < min)
			{
				message = $@"Collection count must be greater than or equal to ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		public static void RequireCountInRange<T>(this T collection, int min, int max,
			string paramName = DefaultParameterName, string message = DefaultRangeMessage)
			where T : ICollection
		{
			if (collection == null)
			{
				var messageTemp = string.Intern(DefaultNullExceptionMessage);
				ThrowArgumentNullException(ref paramName, ref messageTemp);
				return;
			}

			if (collection.Count > max && collection.Count < min)
			{
				message = $@"Collection count must be between ""{min}"" and ""{max}"" inclusive.";
				ThrowArgumentOutOfRangeException(ref paramName, collection, ref message, collection.Count);
			}
		}

		#endregion NULL CHECK FOR OBJECT ARRAY

		#region Null, format, and empty check for strings

		/// <summary>
		///     Extension method that throws ArgumentNullException if target string is null , empty or whitespace.
		///     The method is constrained to objects of string type. The method is intended to be used
		///     for null parameter check.
		/// </summary>
		/// <param name="value">Target string object</param>
		/// <param name="paramName">
		///     Name of the parameter.if pramName is null empty or whitespace default paramName = "Unknown"
		///     will be used.
		/// </param>
		/// <param name="message">
		///     Exception message.If not provided default value is "String value can not be null , empty of white
		///     space."
		/// </param>
		public static void Require(this string value, string paramName = DefaultParameterName,
			string message = DefaultNullExceptionMessage)
		{
			if (value == null)
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		public static void RequireFilled(this string value, string paramName = DefaultParameterName,
			string message = StringExceptionMsg)
		{
			value.RequireNotEmpty(paramName, message);
		}

		public static void RequireNotEmpty(this string value, string paramName = DefaultParameterName,
			string message = StringExceptionMsg)
		{
			value.Require(paramName);

			if (string.IsNullOrWhiteSpace(value))
			{
				ThrowArgumentNullException(ref paramName, ref message);
			}
		}

		public static void RequireFormat(this string value, string regex, string paramName = DefaultParameterName,
			string message = DefaultStringFormatExceptionMsg)
		{
			value.Require(paramName);

			if (!Regex.IsMatch(value, regex))
			{
				ThrowArgumentFormatException(ref message, ref paramName, ref regex);
			}
		}

		#endregion

		// Author: Ahmed Elsawalhy

		#region Range check for comparables

		public static void RequireBelow<T>(this T number, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(max) >= 0)
			{
				message = $@"Parameter must be less than ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		public static void RequireAtMost<T>(this T number, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(max) > 0)
			{
				message = $@"Parameter must be less than or equal to ""{max}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		public static void RequireAbove<T>(this T number, T min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) <= 0)
			{
				message = $@"Parameter must be greater than ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		public static void RequireAtLeast<T>(this T number, T min, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) < 0)
			{
				message = $@"Parameter must be greater than or equal to ""{min}"".";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		public static void RequireInRange<T>(this T number, T min, T max, string paramName = DefaultParameterName,
			string message = DefaultRangeMessage)
			where T : IComparable
		{
			if (number.CompareTo(min) < 0 || number.CompareTo(max) > 0)
			{
				message = $@"Parameter must be between ""{min}"" and ""{max}"" inclusive.";
				ThrowArgumentOutOfRangeException(ref paramName, number, ref message);
			}
		}

		#endregion

		#endregion

		/// <summary>
		/// Author: Ahmed Elsawalhy
		/// </summary>
		public static bool IsEmpty(this IEnumerable e)
		{
			return !e.IsFilled();
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy
		/// </summary>
		public static bool IsFilled(this IEnumerable e)
		{
			return e.Cast<object>().Any();
		}

		#region Strings

		/// <summary>
		///     Credit: http://stackoverflow.com/a/6724896/1919456 <br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string Truncate(this string value, int maxChars, string replacement)
		{
			return value.Length <= maxChars ? value : value.Substring(0, maxChars) + replacement;
		}

		public static string ToTitleCase(this string str)
		{
			return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(str.ToLower());
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy
		/// </summary>
		public static bool IsEmpty(this string str)
		{
			return string.IsNullOrWhiteSpace(str);
		}

		/// <summary>
		/// Author: Ahmed Elsawalhy
		/// </summary>
		public static bool IsFilled(this string str)
		{
			return !str.IsEmpty();
		}

		public static bool IsNotEmpty(this string str)
		{
			return str.IsFilled();
		}

		/// <summary>
		///     Credit: http://stackoverflow.com/a/323670/1919456 <br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string StringLiteral(this string value)
		{
			var replaceDict =
				new Dictionary<string, string>
				{
					["\a"] = @"\a",
					["\b"] = @"\b",
					["\f"] = @"\f",
					["\n"] = @"\n",
					["\r"] = @"\r",
					["\t"] = @"\t",
					["\v"] = @"\v",
					["\0"] = @"\0",
					["\""] = @"\""",
					["\\"] = @"\\"
				};

			return replaceDict.Keys.Aggregate(value, (current, key) => current.Replace(key, replaceDict[key]));
		}

		/// <summary>
		///     Credit: http://stackoverflow.com/a/323670/1919456 <br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string StringUnliteral(this string value)
		{
			var replaceDict =
				new Dictionary<string, string>
				{
					[@"\a"] = "\a",
					[@"\b"] = "\b",
					[@"\f"] = "\f",
					[@"\n"] = "\n",
					[@"\r"] = "\r",
					[@"\t"] = "\t",
					[@"\v"] = "\v",
					[@"\0"] = "\0",
					[@"\"""] = "\"",
					[@"\\"] = "\\"
				};

			return replaceDict.Keys.Aggregate(value, (current, key) => current.Replace(key, replaceDict[key]));
		}

		/// <summary>
		///     Compresses a string and returns a deflate compressed, Base64 encoded string.<br />
		///     Credit: https://stackoverflow.com/a/43357353/1919456<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="uncompressedValue">String to compress</param>
		public static string Compress(this string uncompressedValue)
		{
			using (var compressedStream = new MemoryStream())
			{
				using (var uncompressedStream = new MemoryStream(Encoding.UTF8.GetBytes(uncompressedValue)))
				{
					using (var compressorStream = new DeflateStream(compressedStream, CompressionLevel.Optimal, false))
					{
						uncompressedStream.CopyTo(compressorStream);
					}
				}

				return Convert.ToBase64String(compressedStream.ToArray());
			}
		}

		/// <summary>
		///     Decompresses a deflate compressed, Base64 encoded string and returns an uncompressed string.<br />
		///     Credit: https://stackoverflow.com/a/43357353/1919456<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="compressedValue">String to decompress.</param>
		public static string Decompress(this string compressedValue)
		{
			using (var decompressedStream = new MemoryStream())
			{
				using (var compressedStream = new MemoryStream(Convert.FromBase64String(compressedValue)))
				{
					using (var decompressorStream = new DeflateStream(compressedStream, CompressionMode.Decompress))
					{
						decompressorStream.CopyTo(decompressedStream);
						return Encoding.UTF8.GetString(decompressedStream.ToArray());
					}
				}
			}
		}

		public static string CharLiteral(this char c)
		{
			return c == '\'' ? @"'\''" : string.Format("'{0}'", c);
		}

		public static string XmlEscape(this string unescaped)
		{
			var doc = new XmlDocument();
			XmlNode node = doc.CreateElement("root");
			node.InnerText = unescaped;
			return node.InnerXml;
		}

		#endregion

		#region METHOD THAT ACTUALLY THROWS EXCEPTION

		private static void ThrowArgumentNullException(ref string paramName, ref string message)
		{
			throw new ArgumentNullException(paramName, message);
		}

		private static void ThrowArgumentOutOfRangeException(ref string paramName, object number, ref string message,
			int currentCount = -1)
		{
			throw new ArgumentOutOfRangeException(paramName, number,
				message + ((currentCount >= 0) ? " Current size is " + currentCount : string.Empty));
		}

		private static void ThrowArgumentFormatException(ref string paramName, ref string message, ref string regex)
		{
			throw new ArgumentException(message + " Format: " + regex, paramName);
		}

		#endregion METHOD THAT ACTUALLY THROWS EXCEPTION

		public static bool IsNumeric(this object obj)
		{
			switch (Type.GetTypeCode(obj.GetType()))
			{
				case TypeCode.Byte:
				case TypeCode.SByte:
				case TypeCode.UInt16:
				case TypeCode.UInt32:
				case TypeCode.UInt64:
				case TypeCode.Int16:
				case TypeCode.Int32:
				case TypeCode.Int64:
				case TypeCode.Decimal:
				case TypeCode.Double:
				case TypeCode.Single:
					return true;
				default:
					return false;
			}
		}

		public static bool IsDateTime(this object obj)
		{
			return Type.GetTypeCode(obj.GetType()) == TypeCode.DateTime;
		}

		public static string StringAggregate<T>(this T collection, string separator = ",")
			where T : IEnumerable<string>
		{
			if (collection?.Any() != true)
			{
				return string.Empty;
			}

			return collection.Aggregate((e1, e2) => $"{e1}{separator}{e2}");
		}

		/// <summary>
		/// Credit: Microsoft.Xrm.Client assembly
		/// </summary>
		public static TValue FirstNotNullOrDefault<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, params TKey[] keys)
			=> ((IEnumerable<TKey>)keys)
				.Where<TKey>(new Func<TKey, bool>(dictionary.ContainsKey))
				.Select<TKey, TValue>((Func<TKey, TValue>)(key => dictionary[key]))
				.FirstOrDefault<TValue>();

		/// <summary>
		/// Credit: Microsoft.Xrm.Client assembly
		/// </summary>
		public static string FirstNotNullOrEmpty<TKey>(this IDictionary<TKey, string> dictionary, params TKey[] keys)
			=> ((IEnumerable<TKey>)keys)
				.Where<TKey>((Func<TKey, bool>)(key => dictionary.ContainsKey(key) && !string.IsNullOrEmpty(dictionary[key])))
				.Select<TKey, string>((Func<TKey, string>)(key => dictionary[key]))
				.FirstOrDefault<string>();
	}

	#endregion

	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	//
	// Copyright (c) 2016 Bas van de Sande - JourneyIntoCRM - http://journeyintocrm.com
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
	// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
	// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	//
	// -----------------------------------------------------------------------------------------------------------------------------------------------------------------
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class EntitySerializer
	{
		public static string SerializeObject(Entity entity)
		{
			var ds = new DataSet("XmlData");
			var dt = new DataTable(entity.LogicalName);
			ConvertEntityToDataTable(dt, entity);
			ds.Tables.Add(dt);

			return ds.GetXml();
		}

		public static Entity DeserializeObject(string xml)
		{
			var dataSet = new DataSet();

			var xmlBytes = Encoding.UTF8.GetBytes(xml);

			using (var ms = new MemoryStream(xmlBytes))
			{
				dataSet.ReadXml(ms);
			}

			if (dataSet.Tables.Count <= 0)
			{
				return null;
			}

			var dt = dataSet.Tables[0];

			if (dt.Rows.Count <= 0)
			{
				return null;
			}

			var entity = new Entity(dt.TableName);
			var row = dt.Rows[0];

			foreach (DataColumn column in dt.Columns)
			{
				if (column.ColumnName == "Id")
				{
					entity.Id = (Guid?)SetAttributeValue(row[column.ColumnName]) ?? Guid.Empty;
				}
				else
				{
					entity[column.ColumnName] = SetAttributeValue(row[column.ColumnName]);
				}
			}

			return entity;
		}

		private static void ConvertEntityToDataTable(DataTable dataTable, Entity entity)
		{
			var row = dataTable.NewRow();
			dataTable.Columns.Add("Id");
			row["Id"] = GetAttributeValue(entity.Id);

			foreach (var attribute in entity.Attributes.Where(a => a.Value != null))
			{
				if (!dataTable.Columns.Contains(attribute.Key))
				{
					dataTable.Columns.Add(attribute.Key);
				}

				row[attribute.Key] = GetAttributeValue(attribute.Value);
			}

			foreach (var fv in entity.FormattedValues)
			{
				if (!dataTable.Columns.Contains(fv.Key + "name"))
				{
					dataTable.Columns.Add(fv.Key + "name");
				}

				row[fv.Key + "name"] = fv.Value;
			}

			dataTable.Rows.Add(row);
		}

		private static string GetAttributeValue(object entityValue)
		{
			string objectValue;
			var objectReference = "";
			var objectType = entityValue.GetType().FullName;

			if (entityValue is EntityReference)
			{
				objectValue = ((EntityReference)entityValue).Id.ToString();
				objectReference = ((EntityReference)entityValue).LogicalName;
			}
			else if (entityValue is OptionSetValue)
			{
				objectValue = ((OptionSetValue)entityValue).Value.ToString();
			}
			else if (entityValue is Money)
			{
				objectValue = Convert.ToString(((Money)entityValue).Value, CultureInfo.InvariantCulture.NumberFormat);
			}
			else if (entityValue is AliasedValue)
			{
				var av = (AliasedValue)entityValue;
				objectValue = GetAttributeValue(av.Value);
				objectReference = $"{av.EntityLogicalName},{av.AttributeLogicalName}";
			}
			else if (entityValue is Guid)
			{
				objectValue = entityValue.ToString();
			}
			else
			{
				if (entityValue.IsNumeric())
				{
					objectValue = Convert.ToString(entityValue, CultureInfo.InvariantCulture.NumberFormat);
				}
				else if (entityValue.IsDateTime())
				{
					objectValue = ((DateTime)entityValue).ToUniversalTime().ToString("u");
				}
				else
				{
					objectValue = entityValue.ToString();
				}
			}

			if (!string.IsNullOrWhiteSpace(objectReference))
			{
				objectReference += ",";
			}

			return $"{objectType}|{objectReference}{objectValue}";
		}

		private static object SetAttributeValue(object val)
		{
			if (val == null)
			{
				return null;
			}

			var input = val.ToString();
			var tokens = input.Split('|');

			if (tokens.Length != 2)
			{
				return null;
			}

			if (tokens[0].Equals(typeof(EntityReference).FullName))
			{
				var er = tokens[1].Split(',');
				if (er.Length == 2)
				{
					return new EntityReference(er[0], new Guid(er[1]));
				}
			}
			else if (tokens[0].Equals(typeof(OptionSetValue).FullName))
			{
				int i;
				int.TryParse(tokens[1], out i);
				if (i != int.MinValue)
				{
					return new OptionSetValue(i);
				}
			}
			else if (tokens[0].Equals(typeof(Money).FullName))
			{
				decimal d;
				decimal.TryParse(tokens[1], NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out d);
				if (d != decimal.MinValue)
				{
					return new Money(d);
				}
			}
			else if (tokens[0].Equals(typeof(AliasedValue).FullName))
			{
				var av = tokens[1].Split(',');
				if (av.Length == 3)
				{
					return new AliasedValue(av[0], av[1], SetAttributeValue(av[2]));
				}
			}
			else if (tokens[0].Equals(typeof(Guid).FullName))
			{
				Guid g;
				Guid.TryParse(tokens[1], out g);
				if (g != Guid.Empty)
				{
					return g;
				}
			}
			else if (tokens[0].Equals(typeof(DateTime).FullName))
			{
				DateTime dt;
				DateTime.TryParse(tokens[1], out dt);
				if (dt != DateTime.MinValue)
				{
					return dt.ToUniversalTime();
				}
			}
			else if (tokens[0].Equals(typeof(int).FullName))
			{
				int i32;
				int.TryParse(tokens[1], out i32);
				if (i32 != int.MinValue)
				{
					return i32;
				}
			}
			else if (tokens[0].Equals(typeof(bool).FullName))
			{
				return (tokens[1].ToUpper() == "TRUE");
			}
			else if (tokens[0].Equals(typeof(decimal).FullName))
			{
				decimal sd;
				decimal.TryParse(tokens[1], NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out sd);
				if (sd != decimal.MinValue)
				{
					return sd;
				}
			}
			else
			{
				// all other values
				return tokens[1];
			}

			return null;
		}
	}

	/// <summary>
	///     Reference Article http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx
	///     Provides a method for performing a deep copy of an object.
	///     Binary Serialization is used to perform the copy.
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class ObjectCopier
	{
		/// <summary>
		///     Perform a deep Copy of the object.
		/// </summary>
		/// <typeparam name="T">The type of object being copied.</typeparam>
		/// <param name="source">The object instance to copy.</param>
		/// <returns>The copied object.</returns>
		public static T Clone<T>(this T source) where T : ISerializable
		{
			if (source == null)
			{
				return default(T);
			}

			IFormatter formatter = new BinaryFormatter();
			Stream stream = new MemoryStream();

			using (stream)
			{
				formatter.Serialize(stream, source);
				stream.Seek(0, SeekOrigin.Begin);
				return (T)formatter.Deserialize(stream);
			}
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class ObjectExtensions
	{
		private static readonly MethodInfo cloneMethod = typeof(object).GetMethod("MemberwiseClone",
			BindingFlags.NonPublic | BindingFlags.Instance);

		public static bool IsPrimitive(this Type type)
		{
			if (type == typeof(string))
			{
				return true;
			}

			return type.IsValueType & type.IsPrimitive;
		}

		public static T Copy<T>(this T original)
		{
			return (T)Copy((object)original);
		}

		private static object Copy(object originalObject)
		{
			return InternalCopy(originalObject, new Dictionary<object, object>(new ReferenceEqualityComparer()));
		}

		private static object InternalCopy(object originalObject, IDictionary<object, object> visited)
		{
			if (originalObject == null)
			{
				return null;
			}

			var typeToReflect = originalObject.GetType();

			if (IsPrimitive(typeToReflect))
			{
				return originalObject;
			}

			if (visited.ContainsKey(originalObject))
			{
				return visited[originalObject];
			}

			if (typeof(Delegate).IsAssignableFrom(typeToReflect))
			{
				return null;
			}

			var cloneObject = cloneMethod.Invoke(originalObject, null);

			if (typeToReflect.IsArray)
			{
				var arrayType = typeToReflect.GetElementType();

				if (IsPrimitive(arrayType) == false)
				{
					var clonedArray = (Array)cloneObject;
					clonedArray.ForEach((array, indices) => array.SetValue(InternalCopy(clonedArray.GetValue(indices), visited), indices));
				}
			}

			visited.Add(originalObject, cloneObject);
			CopyFields(originalObject, visited, cloneObject, typeToReflect);
			RecursiveCopyBaseTypePrivateFields(originalObject, visited, cloneObject, typeToReflect);

			return cloneObject;
		}

		private static void RecursiveCopyBaseTypePrivateFields(object originalObject, IDictionary<object, object> visited,
			object cloneObject, Type typeToReflect)
		{
			if (typeToReflect.BaseType == null)
			{
				return;
			}

			RecursiveCopyBaseTypePrivateFields(originalObject, visited, cloneObject, typeToReflect.BaseType);
			CopyFields(originalObject, visited, cloneObject, typeToReflect.BaseType,
				BindingFlags.Instance | BindingFlags.NonPublic, info => info.IsPrivate);
		}

		private static void CopyFields(object originalObject, IDictionary<object, object> visited, object cloneObject,
			IReflect typeToReflect,
			BindingFlags bindingFlags =
				BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy,
			Func<FieldInfo, bool> filter = null)
		{
			foreach (var fieldInfo in typeToReflect.GetFields(bindingFlags))
			{
				if (filter != null && filter(fieldInfo) == false)
				{
					continue;
				}

				if (IsPrimitive(fieldInfo.FieldType))
				{
					continue;
				}

				var originalFieldValue = fieldInfo.GetValue(originalObject);
				var clonedFieldValue = InternalCopy(originalFieldValue, visited);
				fieldInfo.SetValue(cloneObject, clonedFieldValue);
			}
		}

		public static void CopyValuesFrom(this object self, object parent, bool isDeepCopy = false)
		{
			var bindingFlags = BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy;
			var fromFields = parent.GetType().GetFields(bindingFlags);
			var toFields = self.GetType().GetFields(bindingFlags);

			foreach (var fromField in fromFields)
			{
				var toField = toFields.FirstOrDefault(f => fromField.Name == f.Name && fromField.FieldType == f.FieldType);
				var value = fromField.GetValue(parent);
				toField?.SetValue(self, isDeepCopy ? value.Copy() : value);
			}
		}
	}

	#region Helpers

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public class GenericEqualityComparer<T> : EqualityComparer<T>
	{
		private readonly Func<T, T, bool> equator;
		private readonly Func<T, int> hasher;

		public GenericEqualityComparer(Func<T, T,bool> equator, Func<T, int> hasher = null)
		{
			equator.Require(nameof(equator));
			this.equator = equator;
			this.hasher = hasher;
		}

		public override bool Equals(T x, T y)
		{
			return equator(x, y);
		}

		public override int GetHashCode(T obj)
		{
			return hasher == null ? obj.GetHashCode() : hasher(obj);
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public class ReferenceEqualityComparer : EqualityComparer<object>
	{
		public override bool Equals(object x, object y)
		{
			return ReferenceEquals(x, y);
		}

		public override int GetHashCode(object obj)
		{
			return obj.GetHashCode();
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class ArrayExtensions
	{
		public static void ForEach(this Array array, Action<Array, int[]> action)
		{
			if (array.LongLength == 0)
			{
				return;
			}

			var walker = new ArrayTraverse(array);

			do
			{
				action(array, walker.Position);
			}
			while (walker.Step());
		}

		private class ArrayTraverse
		{
			public int[] Position;
			private readonly int[] maxLengths;

			public ArrayTraverse(Array array)
			{
				maxLengths = new int[array.Rank];

				for (var i = 0; i < array.Rank; ++i)
				{
					maxLengths[i] = array.GetLength(i) - 1;
				}

				Position = new int[array.Rank];
			}

			public bool Step()
			{
				for (var i = 0; i < Position.Length; ++i)
				{
					if (Position[i] >= maxLengths[i])
					{
						continue;
					}

					Position[i]++;

					for (var j = 0; j < i; j++)
					{
						Position[j] = 0;
					}

					return true;
				}
				return false;
			}
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class StringHelpers
	{
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class TypeHelpers
	{
		public static IEnumerable<Type> GetHierarchyTree(this Type type)
		{
			return AppDomain.CurrentDomain.GetAssemblies().SelectMany(e => e.GetTypes())
				.Where(t => type.IsAssignableFrom(t) && !t.IsGenericTypeDefinition);
		}

		public static Type GetType(string name, Type assemblyScope = null)
		{
			return assemblyScope == null
				? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes())
					.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name)
				: assemblyScope.Assembly.GetTypes()
					.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name);
		}

		public static Type GetType(string name, params Assembly[] assembliesScope)
		{
			return assembliesScope == null
				? AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes())
					.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name)
				: assembliesScope.SelectMany(a => a.GetTypes())
					.FirstOrDefault(e => e.AssemblyQualifiedName == name || e.FullName == name || e.Name == name);
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class Helpers
	{
		private static readonly IDictionary<Type, Func<object, string>> StringRepresentationsMap =
			new ConcurrentDictionary<Type, Func<object, string>>();

		/// <summary>
		///     Gets the name of the assembly by going back frames in the stack trace.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first assembly in the stack that does not equal this one.
		/// </param>
		/// <param name="skipAssemblyName">[Optional] The name of the assembly to skip if frames are set to '-1'.</param>
		/// <returns>The name of the assembly</returns>
		public static string GetAssemblyName(int skipFrames = -1, string skipAssemblyName = null)
		{
			var currentAssembly = new StackFrame().GetMethod().ReflectedType?.AssemblyQualifiedName;
			skipAssemblyName = string.IsNullOrWhiteSpace(skipAssemblyName) ? currentAssembly : skipAssemblyName;

			if (skipFrames < 0 && !string.IsNullOrWhiteSpace(skipAssemblyName))
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					currentAssembly = method.ReflectedType?.AssemblyQualifiedName;

					if (currentAssembly?.Contains(skipAssemblyName) == true)
					{
						continue;
					}

					break;
				}
			}
			else if (skipFrames >= 0)
			{
				currentAssembly = new StackFrame(skipFrames + 1).GetMethod().ReflectedType?.AssemblyQualifiedName;
			}

			return currentAssembly;
		}

		/// <summary>
		///     Gets the name of the class by going back frames in the stack trace.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first class in the stack that does not equal this one.
		/// </param>
		/// <param name="skipClassNamesParams">
		///     [Optional] The name of the classes to skip if frames are set to '-1'. Must be full
		///     name.
		/// </param>
		/// <returns>The name of the class</returns>
		public static string GetClassName(int skipFrames = -1, params string[] skipClassNamesParams)
		{
			Type declaringType = null;
			var currentClass = new StackFrame().GetMethod().ReflectedType;

			var skipClasses = skipClassNamesParams.ToList();
			skipClasses.Add(currentClass?.FullName);

			if (skipFrames < 0)
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					declaringType = method.ReflectedType;
					var className = declaringType?.FullName ?? string.Empty;

					if (skipClasses.Contains(className))
					{
						continue;
					}

					break;
				}
			}
			else
			{
				declaringType = new StackFrame(skipFrames + 1).GetMethod().ReflectedType;
			}

			return declaringType?.FullName ?? string.Empty;
		}

		/// <summary>
		///     Gets the stack trace of the current execution path.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="skipFrames">
		///     [Optional] The number of frames to go back.<br />
		///     If not specified, it will get the first class in the stack that does not equal this one.
		/// </param>
		/// <param name="skipClassName">
		///     [Optional] The name of the class to skip if frame are set to '-1'. Must be full
		///     name.
		/// </param>
		/// <returns>The stack trace</returns>
		public static string GetStackTrace(int skipFrames = -1, string skipClassName = null)
		{
			var currentClass = new StackFrame().GetMethod().DeclaringType;
			skipClassName = string.IsNullOrWhiteSpace(skipClassName) ? currentClass?.FullName : skipClassName;

			if (skipFrames < 0 && !string.IsNullOrWhiteSpace(skipClassName))
			{
				for (var i = 1; i < 100; i++)
				{
					var method = new StackFrame(i).GetMethod();

					if (method == null)
					{
						break;
					}

					var declaringType = method.DeclaringType;
					var className = declaringType == null ? string.Empty : declaringType.FullName;

					if (className?.Contains(skipClassName) == true)
					{
						continue;
					}

					skipFrames = i - 1;
					break;
				}
			}
			else if (skipFrames < 0)
			{
				skipFrames = 0;
			}

			return new StackTrace(skipFrames + 1).ToString();
		}

		/// <summary>
		///     Add a function that returns a string representing the given type's values to the pool in memory.<br />
		///     This function will be searched for when 'GetStringRepresentation' is called.
		/// </summary>
		/// <param name="evaluator">
		///     A function that takes an object of the given type
		///     and returns a string representation of the values of that type.
		/// </param>
		public static void AddStringRepresentationFunction<T>(Func<T, string> evaluator)
		{
			evaluator.Require();
			StringRepresentationsMap[typeof(T)] = obj => obj is T ? evaluator((T)obj) : null;
		}

		/// <summary>
		///     Gets the function that returns a string representing the given type's values from the pool in memory.<br />
		/// </summary>
		public static Func<object, string> GetStringRepresentationFunction(Type objectType)
		{
			if (objectType == null)
			{
				return null;
			}

			Func<object, string> evaluator;
			StringRepresentationsMap.TryGetValue(objectType, out evaluator);
			return evaluator ?? GetStringRepresentationFunction(objectType.BaseType);
		}

		/// <summary>
		///     Returns a string representing the given object's value.<br />
		///     This can be used in place of 'ToString'.<br />
		///     Custom functions can be defined and added to the pool using 'AddTypeStringRepresentation'.
		/// </summary>
		public static string GetStringRepresentation(object value)
		{
			if (value == null)
			{
				return "null";
			}

			StringBuilder builder;

			if (value is ICollection)
			{
				var collection = (ICollection)value;
				var enumerator = collection.GetEnumerator();
				builder = new StringBuilder();

				var jumpSize = (int)Math.Ceiling(collection.Count / 5.0);
				var index = 0;
				var skipped = false;

				builder.Append("[");

				while (enumerator.MoveNext())
				{
					if (index % jumpSize == 0 || index == 0)
					{
						if (index > 0)
						{
							builder.Append(",");

							if (skipped)
							{
								builder.Append("..,");
							}
						}

						builder.Append($"{GetStringRepresentation(enumerator.Current)}");
					}
					else
					{
						skipped = true;
					}

					index++;
				}

				builder.Append("]");

				return builder.ToString();
			}

			if (value is EntityReference)
			{
				var reference = (EntityReference)value;
				builder = new StringBuilder();

				builder.Append($"{{Logical name = {reference.LogicalName}, Id = {reference.Id}");

				if (!string.IsNullOrWhiteSpace(reference.Name))
				{
					builder.Append($", Name = {reference.Name}");
				}

				builder.Append("}");

				return builder.ToString();
			}

			if (value is Entity)
			{
				var reference = (Entity)value;
				return $"{{Logical name = {reference.LogicalName}, Id = {reference.Id}}}";
			}

			if (value.ToString() != value.GetType().ToString())
			{
				return value.ToString();
			}

			var function = GetStringRepresentationFunction(value.GetType());
			return function == null ? value.ToString() : function(value);
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class CacheHelpers
	{
		/// <summary>
		/// Build an object containing parameters used by the caching methods. The org ID can be provided in order to 
		/// differentiate the cache of different organisations on the same machine.
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="isAddAssemblyTosuffix">Append assembly name to the suffix.</param>
		/// <param name="suffix">Extra text to append on key.</param>
		public static CacheParams BuildCacheParams(IOrganizationService service, bool isAddAssemblyTosuffix = false, string suffix = null)
		{
			return
				new CacheParams
				{
					CacheSuffix = isAddAssemblyTosuffix
						? $"{Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common")}|{suffix}"
						: suffix,
					CacheExpiryTarget = DateTime.Now.AddMinutes(CrmHelpers.GetGenericConfig(service, suffix)?
						.GetAttributeValue<int?>("ldv_configurationcacheduration") ?? 0)
				};
		}

		private const string NullPlaceholder = "YsMemCache|null";

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="key">The string key to add this object under.</param>
		/// <param name="item">The object to add.</param>
		/// <param name="offset">
		///     [OPTIONAL] The time after which to remove the object from the cache.
		/// </param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static T AddToMemCache<T>(string key, T item, DateTimeOffset? offset = null, string cacheKeysuffix = null)
		{
			RemoveFromMemCache(key, cacheKeysuffix);

			ObjectCache cache = MemoryCache.Default;

			if (!String.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (item == null)
			{
				cache.Add(key, NullPlaceholder, offset ?? ObjectCache.InfiniteAbsoluteExpiration);
			}
			else
			{
				cache.Add(key, item, offset ?? ObjectCache.InfiniteAbsoluteExpiration);
			}

			return item;
		}

		/// <summary>
		///     Adds the given object to the MemCache.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="key">The string key to add this object under.</param>
		/// <param name="item">The object to add.</param>
		/// <param name="slidingExpiration">
		///     The duration after which to remove the object from cache, if it was not accessed for that duration.
		/// </param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static T AddToMemCache<T>(string key, T item, TimeSpan slidingExpiration, string cacheKeysuffix = null)
		{
			RemoveFromMemCache(key, cacheKeysuffix);

			ObjectCache cache = MemoryCache.Default;

			if (!String.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (item == null)
			{
				cache.Add(key, NullPlaceholder, new CacheItemPolicy { SlidingExpiration = slidingExpiration });
			}
			else
			{
				cache.Add(key, item, new CacheItemPolicy { SlidingExpiration = slidingExpiration });
			}

			return item;
		}

		/// <summary>
		///     Gets the object from the MemCache.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheKeySuffix">A string to append to all keys. Usually the assembly name.</param>
		/// <param name="defaultValue">The value to return if the key can't be found in the cache.</param>
		public static TItemType GetFromMemCache<TItemType>(string key, string cacheKeySuffix = null,
			TItemType defaultValue = default(TItemType))
		{
			ObjectCache cache = MemoryCache.Default;

			if (!String.IsNullOrWhiteSpace(cacheKeySuffix))
			{
				key += $"|{cacheKeySuffix}";
			}

			if (IsInMemCache(key, cacheKeySuffix))
			{
				var value = cache.Get(key);
				return (TItemType)((value as string) == NullPlaceholder ? default(TItemType) : value);
			}

			return defaultValue;
		}

		public static bool IsInMemCache(string key, string cacheKeySuffix = null)
		{
			ObjectCache cache = MemoryCache.Default;

			if (!String.IsNullOrWhiteSpace(cacheKeySuffix))
			{
				key += $"|{cacheKeySuffix}";
			}

			return cache.Contains(key);
		}

		/// <summary>
		///     Removes the object from the MemCache.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="key">The string key for the object to remove.</param>
		/// <param name="cacheKeysuffix">A string to append to all keys. Usually the assembly name.</param>
		public static void RemoveFromMemCache(string key, string cacheKeysuffix = null)
		{
			ObjectCache cache = MemoryCache.Default;

			if (!String.IsNullOrWhiteSpace(cacheKeysuffix))
			{
				key += $"|{cacheKeysuffix}";
			}

			if (cache.Contains(key))
			{
				cache.Remove(key);
			}
		}

		/// <summary>
		///     Gets the object from the MemCache and add if it doesn't exist.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="key">The string key for the object to get.</param>
		/// <param name="cacheFiller">The function to execute to fill the cache if the key can't be found in the cache.</param>
		/// <param name="cacheParams">A string to append to all keys.</param>
		/// <param name="defaultValue">The value that if returned by the cache would cause the 'filler' to run anyway.</param>
		public static T GetFromMemCacheAdd<T>(string key, Func<T> cacheFiller, CacheParams cacheParams = null,
			T defaultValue = default(T))
		{
			key.RequireNotEmpty(nameof(key));
			cacheFiller.Require(nameof(cacheFiller));

			cacheParams = cacheParams ?? new CacheParams();

			return IsInMemCache(key, cacheParams.CacheSuffix)
				? GetFromMemCache<T>(key, cacheParams.CacheSuffix)
				: AddToMemCache(key, cacheFiller(),
					cacheParams.CacheExpiryTarget, cacheParams.CacheSuffix);
		}
	}

	/// <summary>
	///     credit: http://blog.codeeffects.com/Article/Generate-Random-Numbers-And-Strings-C-Sharp <br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class RandomGenerator
	{
		public enum SymbolFlag
		{
			Uppers = 0,
			Lowers = 1,
			Numbers = 2
		}

		public static string GetRandomString(int length, bool isLetterStart, int numberLetterRatio,
			params string[] symbols)
		{
			var sb = new StringBuilder();

			var digits = symbols.Where(symbol => char.IsDigit(symbol[0])).ToArray();
			var letters = symbols.Where(symbol => char.IsLetter(symbol[0])).ToArray();

			var digitsCount = 0;
			var lettersCount = 0;
			var floatRatio = numberLetterRatio / 100.0;

			for (var i = 0; i < length; i++)
			{
				var filteredSymbols = symbols;

				if (isLetterStart && i == 0)
				{
					lettersCount++;
					filteredSymbols = letters;
				}
				else if (numberLetterRatio > -1)
				{
					if ((lettersCount / (float)length) >= (1 - floatRatio)
						|| (GetRandomNumber(0, 100) <= numberLetterRatio
							&& (digitsCount / (float)length) < floatRatio))
					{
						digitsCount++;
						filteredSymbols = digits;
					}
					else
					{
						lettersCount++;
						filteredSymbols = letters;
					}
				}

				sb.Append(filteredSymbols[GetRandomNumber(0, filteredSymbols.Length)]);
			}

			return sb.ToString();
		}

		public static string GetRandomString(int length, bool isLetterStart, params string[] symbols)
		{
			return GetRandomString(length, isLetterStart, -1, symbols);
		}

		public static string GetRandomString(int length, params string[] symbols)
		{
			return GetRandomString(length, false, -1, symbols);
		}

		public static string GetRandomString(int length, bool isLetterStart, int numberLetterRatio,
			params SymbolFlag[] symbolFlags)
		{
			symbolFlags.Require(nameof(symbolFlags));

			var array = new List<string>();

			var arraySymbolUppers = new[]
									{
										"A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U",
										"V", "W", "X", "Y",
										"Z"
									};

			var arraySymbolLowers = new[]
									{
										"a", "b", "c", "d", "e", "f", "g", "h", "j", "k", "m", "n", "p", "q", "r", "s", "t", "u",
										"v", "w", "x", "y",
										"z"
									};

			var arrayNumbers = new[]
							   {
								   "0", "2", "3", "4", "5", "6", "8", "9"
							   };

			if (symbolFlags.Length <= 0)
			{
				symbolFlags = new[] { SymbolFlag.Uppers, SymbolFlag.Lowers, SymbolFlag.Numbers };
			}

			if (symbolFlags.Contains(SymbolFlag.Uppers))
			{
				array.AddRange(arraySymbolUppers);
			}

			if (symbolFlags.Contains(SymbolFlag.Lowers))
			{
				array.AddRange(arraySymbolLowers);
			}

			if (symbolFlags.Contains(SymbolFlag.Numbers))
			{
				array.AddRange(arrayNumbers);
			}

			return GetRandomString(length, isLetterStart, numberLetterRatio, array.ToArray());
		}

		public static string GetRandomString(int length, bool isLetterStart, params SymbolFlag[] symbolFlags)
		{
			return GetRandomString(length, isLetterStart, -1, symbolFlags);
		}

		public static string GetRandomString(int length, params SymbolFlag[] symbolFlags)
		{
			return GetRandomString(length, false, -1, symbolFlags);
		}

		public static int GetRandomNumber(int maxNumber = 100)
		{
			return GetRandomNumber(0, maxNumber);
		}

		public static int GetRandomNumber(int minNumber, int maxNumber)
		{
			using (var rngGenerator = new RNGCryptoServiceProvider())
			{
				var b = new byte[4];
				rngGenerator.GetBytes(b);
				var seed = (b[0] & 0x7f) << 24 | b[1] << 16 | b[2] << 8 | b[3];
				var r = new Random(seed);

				return r.Next(minNumber, maxNumber);
			}
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class DateTimeHelpers
	{
		/// <summary>
		///     Gets the number of seconds that has passed since 1/1/1970 12AM.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="endDate">[OPTIONAL=UtcNow] The date to count to.</param>
		/// <returns>Number of seconds.</returns>
		public static long GetSecondsSinceEpoch(DateTime? endDate = null)
		{
			return (long)(endDate ?? DateTime.UtcNow).Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
		}

		/// <summary>
		///     Gets the day occurence of month.<br />
		///     Credit: http://stackoverflow.com/a/18621645/1919456
		/// </summary>
		public static DateTime? GetDayOccurrenceOfMonth(DateTime dateOfMonth, DayOfWeek dayOfWeek, bool isLastOccurrence)
		{
			return GetDayOccurrenceOfMonth(dateOfMonth, dayOfWeek, 5, isLastOccurrence);
		}

		/// <summary>
		///     Gets the day occurence of month.<br />
		///     Credit: http://stackoverflow.com/a/18621645/1919456
		/// </summary>
		public static DateTime? GetDayOccurrenceOfMonth(DateTime dateOfMonth, DayOfWeek dayOfWeek, int occurrence,
			bool isLastOccurrence)
		{
			occurrence.RequireInRange(1, 5, "occurrence", "Occurrence must be greater than zero and less than 6.");

			if (isLastOccurrence)
			{
				occurrence = 5;
			}

			// Change to first day of the month
			var dayOfMonth = dateOfMonth.AddDays(1 - dateOfMonth.Day);

			// Find first dayOfWeek of this month;
			if (dayOfMonth.DayOfWeek > dayOfWeek)
			{
				dayOfMonth = dayOfMonth.AddDays(7 - (int)dayOfMonth.DayOfWeek + (int)dayOfWeek);
			}
			else
			{
				dayOfMonth = dayOfMonth.AddDays((int)dayOfWeek - (int)dayOfMonth.DayOfWeek);
			}

			// add 7 days per occurrence
			dayOfMonth = dayOfMonth.AddDays(7 * (occurrence - 1));

			// make sure this occurrence is within the original month
			if (dayOfMonth.Month == dateOfMonth.Month)
			{
				return dayOfMonth;
			}
			else
			{
				if (isLastOccurrence)
				{
					return dayOfMonth.AddDays(-7);
				}

				return null;
			}
		}
	}

	/// <summary>
	///     credit: http://pietschsoft.com/post/2008/02/net-35-json-serialization-using-the-datacontractjsonserializer <br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class SerialiserHelpers
	{
		// credit: http://stackoverflow.com/a/12845153/1919456
		public static string SerialiseBase64<T>(this T value) where T : class
		{
			using (var stream = new MemoryStream())
			{
				using (var writer = XmlDictionaryWriter.CreateBinaryWriter(stream))
				{
					var serialiser = new DataContractSerializer(value.GetType());
					serialiser.WriteObject(writer, value);
					return Convert.ToBase64String(stream.ToArray());
				}
			}
		}

		public static T DeserialiseBase64<T>(this string base64) where T : class
		{
			using (var stream = new MemoryStream(Convert.FromBase64String(base64)))
			{
				using (var reader = XmlDictionaryReader
					.CreateBinaryReader(stream, XmlDictionaryReaderQuotas.Max))
				{
					var serialiser = new DataContractSerializer(typeof(T));
					return (T)serialiser.ReadObject(reader);
				}
			}
		}

		public static string SerialiseStrictXml<T>(T obj) where T : class
		{
			using (var stream = new MemoryStream())
			{
				var serialiser = new DataContractSerializer(obj.GetType());
				serialiser.WriteObject(stream, obj);
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		public static T DeserialiseStrictXml<T>(string xml) where T : class
		{
			using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(xml)))
			{
				var serialiser = new DataContractSerializer(typeof(T));
				return (T)serialiser.ReadObject(stream);
			}
		}

		/// <summary>
		///     Author: Ramy Victor
		/// </summary>
		public static string SerialiseContractXml<T>(this T obj) where T : class
		{
			using (var stream = new MemoryStream())
			{
				var serialiser = new XmlSerializer(typeof(T));
				serialiser.Serialize(stream, obj);
				stream.Position = 0;
				return Encoding.UTF8.GetString(stream.ToArray());
			}
		}

		/// <summary>
		///     Author: Ramy Victor
		/// </summary>
		public static T DeserialiseContractXml<T>(this string xml) where T : class
		{
			using (var read = new StringReader(xml))
			{
				using (XmlReader reader = new XmlTextReader(read))
				{
					var serialiser = new XmlSerializer(typeof(T));
					return (T)serialiser.Deserialize(reader);
				}
			}
		}

		public static string SerialiseSimpleJson(IDictionary<string, string> dictionary, bool isUnformatted = false)
		{
			var pairs = dictionary.Select(pair =>
				string.Format((isUnformatted ? string.Empty : "\t") + "\"{0}\":\"{1}\"", pair.Key, pair.Value?.StringLiteral()))
				.ToArray();
			return "{" + (isUnformatted ? string.Empty : "\r\n") + (pairs.Any() ?
				pairs.Aggregate((e1, e2) => e1 + "," + (isUnformatted ? string.Empty : "\r\n") + e2) : string.Empty)
				+ (isUnformatted ? string.Empty : "\r\n") + "}";
		}

		public static IDictionary<string, string> DeserialiseSimpleJson(string json)
		{
			var matches = Regex.Matches(json,
				@"['""]?([^""'\s]*?)['""]?(?:\:\s*)(true|false|\d+|['""](?:\\""|\\'|[^'""])*?['""])");

			if (matches.Count <= 0)
			{
				throw new FormatException("JSON is empty or poorly formatted.");
			}

			var dictionary = new Dictionary<string, string>();

			foreach (Match match in matches)
			{
				var groups = match.Groups;

				// the whole string is a match and the rest are pairs
				if ((groups.Count - 1) % 2 != 0)
				{
					throw new FormatException("JSON is poorly formatted.");
				}

				if (string.IsNullOrEmpty(groups[2].Value))
				{
					continue;
				}

				dictionary.Add(groups[1].Value, groups[2].Value.Trim('\'', '\"').StringUnliteral());
			}

			return dictionary;
		}

		/// <summary>
		/// Serialises the object into JSON using the .NET <see cref="DataContractJsonSerializer" />.<br />
		/// Classes must be decorated with <see cref="DataContract" /> and member with <see cref="DataMember" />.<br />
		/// To aid in serialisation, known types can be passed, or pass null and the method will automatically
		/// attempt to find the types. You can optionally limit the scope of the search to the provided type's assembly.
		/// </summary>
		/// <typeparam name="T">Return type.</typeparam>
		/// <param name="obj">The object to serialise.</param>
		/// <param name="isSerializeReadOnlyTypes">If set to <c>true</c> will serialise <c>readonly</c>
		/// and properties with a <c>get</c> only.</param>
		/// <param name="knownTypes">The known types to consider when serialising.</param>
		/// <param name="assembliesScope">The assemblies scope.</param>
		/// <param name="surrogate">The surrogate.</param>
		/// <param name="latestError">The latest error.</param>
		public static string SerialiseContractJson<T>(this T obj, bool isSerializeReadOnlyTypes = false, Type[] knownTypes = null,
			Assembly[] assembliesScope = null, IDataContractSurrogate surrogate = null, string latestError = null)
			where T : class
		{
			knownTypes = knownTypes ?? new Type[0];

			try
			{
				using (var memoryStream = new MemoryStream())
				{
					var serialiser = new DataContractJsonSerializer(typeof(T),
						BuildSerialisationSettings(isSerializeReadOnlyTypes, knownTypes, surrogate));
					serialiser.WriteObject(memoryStream, obj);
					return Encoding.Default.GetString(memoryStream.ToArray());
				}
			}
			catch (SerializationException ex)
			{
				var serialised = HandleSerialisationException(ref knownTypes, assembliesScope, ref latestError, ex);

				if (serialised)
				{
					return obj.SerialiseContractJson(isSerializeReadOnlyTypes, knownTypes, assembliesScope, surrogate, latestError);
				}

				return null;
			}
		}

		/// <summary>
		/// Deserialises the object into JSON using the .NET <see cref="DataContractJsonSerializer" />.<br />
		/// Classes must be decorated with <see cref="DataContract" /> and member with <see cref="DataMember" />.<br />
		/// To aid in deserialisation, known types can be passed, or pass null and the method will automatically
		/// attempt to find the types. You can optionally limit the scope of the search to the provided type's assembly.
		/// </summary>
		/// <typeparam name="T">Return type.</typeparam>
		/// <param name="json">The json.</param>
		/// <param name="isSerializeReadOnlyTypes">If set to <c>true</c> will deserialise <c>readonly</c>
		/// and properties with a <c>get</c> only.</param>
		/// <param name="knownTypes">The known types to consider when deserialising.</param>
		/// <param name="assembliesScope">The assemblies scope.</param>
		/// <param name="surrogate">The surrogate.</param>
		/// <param name="latestError">The latest error.</param>
		public static T DeserialiseContractJson<T>(this string json, bool isSerializeReadOnlyTypes = false, Type[] knownTypes = null,
			Assembly[] assembliesScope = null, IDataContractSurrogate surrogate = null, string latestError = null)
			where T : class
		{
			knownTypes = knownTypes ?? new Type[0];

			try
			{
				using (var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(json)))
				{
					var serialiser = new DataContractJsonSerializer(typeof(T),
						BuildSerialisationSettings(isSerializeReadOnlyTypes, knownTypes, surrogate));
					return (T)serialiser.ReadObject(memoryStream);
				}
			}
			catch (SerializationException ex)
			{
				var serialised = HandleSerialisationException(ref knownTypes, assembliesScope, ref latestError, ex);

				if (serialised)
				{
					return json.DeserialiseContractJson<T>(isSerializeReadOnlyTypes, knownTypes, assembliesScope,
						surrogate, latestError);
				}

				return null;
			}
		}

		private static bool HandleSerialisationException(ref Type[] knownTypes, Assembly[] assembliesScope,
			ref string latestError, SerializationException ex)
		{
			if (latestError == ex.Message)
			{
				throw new SerializationException($"Type is unsupported by [de]serialisation => '{latestError}'.");
			}

			latestError = ex.Message;

			var match = Regex.Match(ex.Message, @"Type '(.+?)'");

			if (match.Groups.Count <= 1)
			{
				match = Regex.Match(ex.Message, @"'https?://.*?/([\w\.]+:(\w+))'");
			}

			if (match.Groups.Count > 1)
			{
				knownTypes = knownTypes.Union(
					new[]
					{
						TypeHelpers.GetType(match.Groups[1].ToString().Replace(':', '.'), assembliesScope)
							?? TypeHelpers.GetType(match.Groups[2].ToString(), assembliesScope)
					}).Where(e => e != null).ToArray();
				return true;
			}

			throw new SerializationException($"Type is unsupported by [de]serialisation => '{latestError}'.");
		}

		private static DataContractJsonSerializerSettings BuildSerialisationSettings(bool isSerializeReadOnlyTypes,
			Type[] knownTypes, IDataContractSurrogate surrogate)
		{
			return new DataContractJsonSerializerSettings
				   {
					   UseSimpleDictionaryFormat = true,
					   SerializeReadOnlyTypes = isSerializeReadOnlyTypes,
					   KnownTypes = knownTypes,
					   DataContractSurrogate = surrogate
				   };
		}

		/// <summary>
		/// Credit: https://stackoverflow.com/a/9347678/1919456
		/// </summary>
		/// <seealso cref="System.Runtime.Serialization.IDataContractSurrogate" />
		public class DateTimeCrmContractSurrogate : IDataContractSurrogate
		{
	        private static readonly Regex dateRegex = new Regex(@"/Date\((\d+)([-+])?(\d+)?\)/");
	        private static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

	        public object GetCustomDataToExport(Type clrType, Type dataContractType)
	        {
	            // not used
	            return null;
	        }

	        public object GetCustomDataToExport(System.Reflection.MemberInfo memberInfo, Type dataContractType)
	        {
	            // not used
	            return null;
	        }

	        public Type GetDataContractType(Type type)
	        {
	            // not used
	            return type;
	        }

	        public object GetDeserializedObject(object obj, Type targetType)
	        {
	            // for debugging
	            //Console.WriteLine("GetDeserializedObject: obj = {0} ({1}), targetType = {2}", obj, obj.GetType(), targetType);

	            if (obj is DataCollection<string, object> dataCollection)
	            {
		            foreach (var item in dataCollection.ToArray())
		            {
			            dataCollection[item.Key] = ConvertDate(item.Value as string) ?? item.Value;
		            }
	            }

	            if (obj is IDictionary<string, object> dictionary)
	            {
		            foreach (var item in dictionary.ToArray())
		            {
			            dictionary[item.Key] = ConvertDate(item.Value as string) ?? item.Value;
		            }
	            }

		        return CustomIterator(obj);
	        }

			protected virtual object CustomIterator(object obj)
			{
				return obj;
			}

			protected static DateTime? ConvertDate(string unparsedDate)
			{
				if (unparsedDate != null)
				{
					// check if we match the DateTime format
					Match match = dateRegex.Match(unparsedDate);

					if (match.Success)
					{
						// try to parse the string into a long. then create a datetime and convert to local time.
						long msFromEpoch;

						if (long.TryParse(match.Groups[1].Value, out msFromEpoch))
						{
							TimeSpan fromEpoch = TimeSpan.FromMilliseconds(msFromEpoch);
							return TimeZoneInfo.ConvertTimeFromUtc(epoch.Add(fromEpoch), TimeZoneInfo.Local);
						}
					}
				}

				return null;
			}

			public void GetKnownCustomDataTypes(System.Collections.ObjectModel.Collection<Type> customDataTypes)
	        {
	            // not used   
	        }

	        public object GetObjectToSerialize(object obj, Type targetType)
	        {
	            // for debugging
	            //Console.WriteLine("GetObjectToSerialize: obj = {0} ({1}), targetType = {2}", obj, obj.GetType(), targetType);
	            return obj;
	        }

	        public Type GetReferencedTypeOnImport(string typeName, string typeNamespace, object customData)
	        {
	            // not used
	            return null;
	        }

	        public System.CodeDom.CodeTypeDeclaration ProcessImportedType(System.CodeDom.CodeTypeDeclaration typeDeclaration, System.CodeDom.CodeCompileUnit compileUnit)
	        {
	            // not used
	            return typeDeclaration;
	        }
	    }
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class CrmHelpers
	{
		public static string[] NonUpdatableFields =
			{
				"createdby",
				"createdon",
				"createdonbehalfby",
				"importsequencenumber",
				"modifiedby",
				"modifiedon",
				"modifiedonbehalfby",
				"owningbusinessunit",
				"owningteam",
				"owninguser",
				"timezoneruleversionnumber",
				"utcconversiontimezonecode",
				"versionumber",
			};

		/// <summary>
		///     Retrieves the generic configuration record from CRM. All fields are returned.<br />
		///     If none is found, an empty entity record is returned.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="service">CRM Organisation Service</param>
		/// <param name="orgId">CRM Organisation ID to make caching unique</param>
		public static Entity GetGenericConfig(IOrganizationService service, string orgId)
		{
			var cacheKey = $"Yagasoft.Common.CrmHelpers.GetGenericConfig";
			var configLocal = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId);

			if (configLocal == null)
			{
				configLocal =
					(from configQ in new OrganizationServiceContext(service).CreateQuery("ldv_genericconfiguration")
					 where (int)configQ["statecode"] == 0
					 select configQ).FirstOrDefault();
				CacheHelpers.AddToMemCache(cacheKey, configLocal,
					DateTime.Now.AddMinutes(configLocal?.GetAttributeValue<int>("ldv_configurationcacheduration") ?? 0), orgId);
			}

			return configLocal
				?? new Entity("ldv_genericconfiguration")
				{
					["ldv_name"] = "Generic Config"
				};
		}

		internal static DateTime GetMetadataCacheExpiryDate(IOrganizationService service, string orgId)
		{
			return DateTime.Now.AddMinutes(GetGenericConfig(service, orgId)?
				.GetAttributeValue<int>("ldv_metadatacacheduration") ?? 0);
		}

		/// <summary>
		///     Get the value of the primary name field of the record.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string GetRecordName(IOrganizationService service, Entity record, string orgId)
		{
			return record.GetAttributeValue<string>(MetadataHelpers
				.GetEntityAttribute<string>(service, record.LogicalName, MetadataHelpers.EntityAttribute.PrimaryNameAttribute, orgId));
		}

		/// <summary>
		///     Get the value of the primary name field of the record.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string GetRecordName(IOrganizationService service, string logicalName, Guid id, string orgId,
			string primaryNameField = null)
		{
			var nameField = string.IsNullOrWhiteSpace(primaryNameField)
				? MetadataHelpers.GetEntityAttribute<string>(service, logicalName, MetadataHelpers.EntityAttribute.PrimaryNameAttribute,
					orgId)
				: primaryNameField;
			return service.Retrieve(logicalName, id, new ColumnSet(nameField)).GetAttributeValue<string>(nameField);
		}

		public static bool IsRecordExists(IOrganizationService service, string logicalName, Guid id, bool isActivity = false)
		{
			var query = new QueryByAttribute(logicalName);
			query.AddAttributeValue(isActivity ? "activityid" : logicalName + "id", id);
			query.ColumnSet = new ColumnSet(false);
			return service.RetrieveMultiple(query).Entities.Any();
		}

		/// <summary>
		///     Get the total number of records returned by the given query using a modded binary search algorithm.<br />
		///     It is recommended that the query's column-set is set to 'false' for speed.<br />
		///     Please note that the 'PageInfo' object in the query will be overwritten.<br />
		///     This does NOT work with CRM Online.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static int GetRecordsCount(IOrganizationService service, QueryExpression query, int countPerPage = 5000,
			string cookie = null, int lowerPageLimit = 1, int upperPageLimit = int.MaxValue)
		{
			var minPage = lowerPageLimit;
			var minPageCount = GetCountInPage(service, query, cookie, minPage, countPerPage);

			// first page is already partially filled or empty, so there are no records after for sure
			if (minPageCount >= 0 && minPageCount < countPerPage)
			{
				return minPageCount;
			}

			var maxPage = minPage;
			int maxPageCount;

			// get max page with partial fill or no records, after which there are surely no records
			// jump pages using an exponent of 2 because it's more likely that there are low number of pages than high
			while (true)
			{
				maxPage = maxPage * 2;
				maxPage = Math.Min(maxPage, upperPageLimit);
				maxPageCount = GetCountInPage(service, query, cookie, maxPage, countPerPage);

				// a filled page is considered a minimum, so set it to reduce search range
				if (maxPageCount == countPerPage)
				{
					minPage = maxPage;
					minPageCount = maxPageCount;
				}
				else
				{
					break;
				}
			}

			var isMaxNextToMin = (minPage + 1) == maxPage;
			var isMaxPageEmpty = maxPageCount == 0;
			var isMaxPagePartial = maxPageCount > 0 && maxPageCount < countPerPage;

			// max page is next to min full page, and is empty or partially filled, so we have reached the end
			if (isMaxPagePartial || (isMaxPageEmpty && isMaxNextToMin))
			{
				return ((maxPage - 1) * countPerPage) + maxPageCount;
			}

			int currentPage;
			int currentPageCount;

			while (true)
			{
				// get the current page in the middle point between min and max
				currentPage = (int)Math.Ceiling((maxPage + minPage) / 2d);

				// if current is not min or max, get its count
				if (currentPage != minPage && currentPage != maxPage)
				{
					currentPageCount = GetCountInPage(service, query, cookie, currentPage, countPerPage);
				}
				else
				{
					currentPageCount = currentPage == minPage ? minPageCount : maxPageCount;
				}

				var isCurrentNextToMin = (minPage + 1) == currentPage;
				var isCurrentNextToMax = (maxPage - 1) == currentPage;
				var isCurrentPageEmpty = currentPageCount == 0;
				var isCurrentPagePartial = currentPageCount > 0 && currentPageCount < countPerPage;
				var isCurrentPageFull = currentPageCount == countPerPage;

				// current page is next to min full page or max empty page
				// and is empty or partially filled, so we have reached the end
				if (isCurrentPagePartial
					|| (isCurrentPageEmpty && isCurrentNextToMin) || (isCurrentPageFull && isCurrentNextToMax))
				{
					break;
				}

				if (isCurrentPageEmpty)
				{
					maxPage = currentPage;
				}

				if (isCurrentPageFull)
				{
					minPage = currentPage;
				}
			}

			return ((currentPage - 1) * countPerPage) + currentPageCount;
		}

		public static int GetCountInPage(IOrganizationService service, QueryExpression query, string cookie = null,
			int page = 1, int countPerPage = 5000)
		{
			query.PageInfo = query.PageInfo ?? new PagingInfo();
			query.PageInfo.Count = countPerPage;
			query.PageInfo.PageNumber = page;
			query.PageInfo.PagingCookie = query.PageInfo.PagingCookie ?? cookie;
			query.ColumnSet = query.ColumnSet ?? new ColumnSet(false);
			var result = service.RetrieveMultiple(query);
			query.PageInfo.PagingCookie = result.PagingCookie ?? cookie;
			return result.Entities.Count;
		}

		/// <summary>
		///     Gets records from CRM using the query given.<br />
		///     Pass '-1' for limit to get all records, and pass '-1' to page to ignore pages.
		///     The cookie is saved in the query itself during retrieval, so either save the cookie somewhere
		///     and reset it before passing it here, or simply reuse the query for next pages.<br />
		///     You should not skip pages with CRM Online.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static IEnumerable<Entity> RetrieveRecords(IOrganizationService service, QueryExpression query,
			int limit = -1, int page = -1)
		{
			query.PageInfo =
				new PagingInfo
				{
					PageNumber = page <= 0
						? (query.PageInfo == null || query.PageInfo.PageNumber <= 0
							? 1
							: query.PageInfo.PageNumber)
						: page,
					Count = limit <= 0
						? (query.PageInfo == null || query.PageInfo.Count <= 0
							? 5000
							: query.PageInfo.Count)
						: (limit > 5000 ? 5000 : limit)
				};

			limit = limit <= 0 ? int.MaxValue : limit;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				// fetch the records
				records = service.RetrieveMultiple(query);

				// next time get the next bundle of records
				query.PageInfo.PagingCookie = records.PagingCookie;
				query.PageInfo.PageNumber++;

				// add to existing list
				entities.AddRange(records.Entities);
			}
			while (records.MoreRecords && entities.Count < limit && page <= 0);

			return entities;
		}

		/// <summary>
		///     Gets records from CRM using the FetchXML given.<br />
		///     Pass '-1' for limit to get all records, and pass '-1' to page to ignore pages.
		///     You should not skip pages with CRM Online.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static IEnumerable<Entity> RetrieveRecords(IOrganizationService service, string fetchXml,
			int limit = -1, int page = -1)
		{
			var isAllPages = page <= 0;
			page = page <= 0 ? 1 : page;
			var loopLimit = limit <= 0 ? int.MaxValue : limit;
			var count = limit > 5000 ? 5000 : limit;
			string cookie = null;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				fetchXml = SetFetchPaging(fetchXml, page, count, cookie);

				// fetch the records
				records = service.RetrieveMultiple(new FetchExpression(fetchXml));

				// next time get the next bundle of records
				cookie = records.PagingCookie;
				page++;

				// add to existing list
				entities.AddRange(records.Entities);
			}
			while (records.MoreRecords && entities.Count < loopLimit && isAllPages);

			return entities;
		}

		private static string SetFetchPaging(string fetchXml, int page, int count = -1, string cookie = null)
		{
			var doc = new XmlDocument();
			doc.LoadXml(fetchXml);

			var fetchNode = doc.SelectNodes("//fetch")?.Cast<XmlNode>().FirstOrDefault();

			if (fetchNode == null)
			{
				throw new FormatException("FetchXML is not properly formatted.");
			}

			var tempDoc = fetchNode.OwnerDocument;

			if (tempDoc == null)
			{
				throw new FormatException("Couldn't find owner document in FetchXML node.");
			}

			if (fetchNode.Attributes == null)
			{
				throw new FormatException("Couldn't find attributes collection in FetchXML node.");
			}

			var attribute = tempDoc.CreateAttribute("page");
			attribute.Value = page.ToString();
			fetchNode.Attributes.SetNamedItem(attribute);

			if (count > 0)
			{
				attribute = tempDoc.CreateAttribute("count");
				attribute.Value = count.ToString();
				fetchNode.Attributes.SetNamedItem(attribute);
			}

			if (!string.IsNullOrWhiteSpace(cookie))
			{
				attribute = tempDoc.CreateAttribute("paging-cookie");
				attribute.Value = cookie;
				fetchNode.Attributes.SetNamedItem(attribute);
			}

			return doc.OuterXml;
		}

		/// <summary>
		///     Extracts the entity references from a record URL. Usually the URL is provided as input to a custom activity.<br />
		///     Execution Context can be null, it is used to cache inside a plugin only.<br />
		///     Author: Ahmed Elsawalhy<br />
		///     Credit: Yousra Mohamed
		/// </summary>
		public static List<EntityReference> GetEntityReferencesFromUrls(IOrganizationService service, string orgId,
			params string[] dynamicUrlParams)
		{
			// loop over dynamic urls to retrieve entity reference
			return (from url in dynamicUrlParams
					where url.Contains("etc=") && url.Contains("id=")
					select url.Trim().Split('?')
					into urlParts
					select urlParts[1].Split('&')
					into urlParams
					let objectTypeCode = urlParams.First(p => p.Contains("etc=")).Replace("etc=", "")
					let objectId = urlParams.First(p => p.Contains("id=")).Replace("id=", "")
					let entityName = MetadataHelpers.GetEntityNameUsingTypeCode(service, int.Parse(objectTypeCode), orgId)
					select new EntityReference(entityName, Guid.Parse(objectId))).ToList();
		}

        public static T ExtractEntityByAlias<T>(this Entity sourceEntity, string alias)
            where T : Entity
        {
            sourceEntity.Require(nameof(sourceEntity));
            alias.RequireNotEmpty(nameof(alias));

            var values = sourceEntity.Attributes
                .Where(kv => kv.Key.StartsWith($"{alias}."))
                .Select(kv => kv.Value as AliasedValue)
                .Where(v => v != null).ToArray();

	        var logicalName = values.FirstOrDefault()?.EntityLogicalName;

	        if (logicalName == null)
	        {
		        return null;
	        }

            var newEntity = new Entity(logicalName);

            foreach (var aliasedValue in values)
            {
                newEntity[aliasedValue.AttributeLogicalName] = aliasedValue.Value;
            }

            var formattedValues = sourceEntity.FormattedValues
                .Where(kv => kv.Key.StartsWith($"{alias}."));

            foreach (var kv in formattedValues)
            {
                newEntity.FormattedValues[kv.Key.Replace($"{alias}.", "")] = kv.Value;
            }

            return newEntity.ToEntity<T>();
        }

        public static T ExcludeExistingValues<T>(this T newRecord, Entity existingRecord)
            where T : Entity
        {
            newRecord.Require(nameof(newRecord));
            existingRecord.Require(nameof(existingRecord));

            // IDs' will probably match and be removed below; so restore it after
            var id = newRecord.Id;

            // 'ToArray' is used to create a new collection; modifying collections mid iteration causes exception
            foreach (var attribute in newRecord.Attributes.ToArray())
            {
                var key = attribute.Key;
                var value = attribute.Value;

                bool isEqual;

                switch (value)
                {
                    case OptionSetValue optionSetValue:
                        var existingOsValue = existingRecord.GetAttributeValue<OptionSetValue>(key);
                        isEqual = optionSetValue.Value == existingOsValue?.Value;
                        break;

                    case EntityReference entityReference:
                        var existingRefValue = existingRecord.GetAttributeValue<EntityReference>(key);
                        isEqual = entityReference.Id == existingRefValue?.Id;
                        break;

                    case Money money:
                        var existingMoneyValue = existingRecord.GetAttributeValue<Money>(key);
                        isEqual = money.Value == existingMoneyValue?.Value;
                        break;

                    default:
                        var existingValue = existingRecord.GetAttributeValue<object>(key);
                        isEqual = value == existingValue || value?.Equals(existingValue) == true;
                        break;
                }

                if (isEqual)
                {
                    newRecord.Attributes.Remove(key);
                }
            }

            newRecord.Id = id;

            return newRecord;
        }

		/// <summary>
		///     Executes given requests in a transaction. The returned value should only be taken into consideration
		///     if 'isReturnResponses' is 'true'.<br />
		///     All executed requests will be rolled back if one fails.<br />
		///     The handler takes 'current batch index (1, 2 ... etc.), total batch count, responses' as parameters.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteTransaction(this IEnumerable<OrganizationRequest> requestsEnumerable,
			IOrganizationService service, bool isReturnResponses = false, int batchSize = 1000,
	        Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			var requests = requestsEnumerable?.ToList();

	        if (requests?.Any() != true)
	        {
                return new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
	        }

            var bulkRequest =
                new ExecuteTransactionRequest
                {
                    Requests = new OrganizationRequestCollection(),
                    ReturnResponses = isReturnResponses
                };

            var responses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
	        var perBulkResponses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();

            var batchCount = Math.Ceiling(requests.Count / (double)batchSize);

            // take bulk size only for each iteration
            for (var i = 0; i < batchCount; i++)
            {
                // clear the previous batch
                bulkRequest.Requests.Clear();
	            perBulkResponses.Clear();

                // take batches
                bulkRequest.Requests.AddRange(requests.Skip(i * batchSize).Take(batchSize));
                var bulkResponses = (ExecuteTransactionResponse)service.Execute(bulkRequest);

                // no need to build a response
                if (!isReturnResponses)
                {
	                bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
                    continue;
                }

                for (var j = 0; j < bulkResponses.Responses.Count; j++)
                {
                    var request = bulkRequest.Requests[j];
                    var bulkResponse = bulkResponses.Responses[j];

                    var response =
                        new ExecuteBulkResponse
                        {
                            RequestType = request.GetType(),
                            Response = bulkResponse,
                            ResponseType = bulkResponse?.GetType()
                        };
                    responses[request] = response;
					perBulkResponses[request] = response;
                }

				bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
            }

            return responses;
        }

		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteBulk(IOrganizationService service,
			IEnumerable<OrganizationRequest> requests,
			bool isReturnResponses = false, int batchSize = 1000, bool isContinueOnError = true,
			Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			return requests.ExecuteBulk(service, isReturnResponses, batchSize, isContinueOnError, bulkFinishHandler);
		}

		/// <summary>
		///     Executes given requests in bulk. The returned value should only be taken into consideration
		///     if 'isReturnResponses' is 'true'.<br />
		///     The handler takes 'current batch index (1, 2 ... etc.), total batch count, responses' as parameters.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static IDictionary<OrganizationRequest, ExecuteBulkResponse> ExecuteBulk(this IEnumerable<OrganizationRequest> requestsEnumerable,
			IOrganizationService service,
			bool isReturnResponses = false, int batchSize = 1000, bool isContinueOnError = true,
			Action<int, int, IDictionary<OrganizationRequest, ExecuteBulkResponse>> bulkFinishHandler = null)
		{
			var requests = requestsEnumerable?.ToList();

			if (requests?.Any() != true)
			{
				return new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
			}

			var bulkRequest =
				new ExecuteMultipleRequest
				{
					Requests = new OrganizationRequestCollection(),
					Settings =
						new ExecuteMultipleSettings
						{
							ContinueOnError = isContinueOnError,
							ReturnResponses = isReturnResponses
						}
				};

			var responses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();
			var perBulkResponses = new Dictionary<OrganizationRequest, ExecuteBulkResponse>();

			var batchCount = Math.Ceiling(requests.Count / (double)batchSize);

			// take bulk size only for each iteration
			for (var i = 0; i < batchCount; i++)
			{
				// clear the previous batch
				bulkRequest.Requests.Clear();
				perBulkResponses.Clear();

				// take batches
				bulkRequest.Requests.AddRange(requests.Skip(i * batchSize).Take(batchSize));
				var bulkResponses = (ExecuteMultipleResponse)service.Execute(bulkRequest);

				// no need to build a response
				if (!isReturnResponses)
				{
					// break on error and no 'continue on error' option
					if (!isContinueOnError && (bulkResponses.IsFaulted || bulkResponses.Responses.Any(e => e.Fault != null)))
					{
						break;
					}
					else
					{
						bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);
						continue;
					}
				}

				for (var j = 0; j < bulkResponses.Responses.Count; j++)
				{
					var request = bulkRequest.Requests[j];
					var bulkResponse = bulkResponses.Responses[j];
					var fault = bulkResponse.Fault;
					string faultMessage = null;

					// build fault message
					if (fault != null)
					{
						var builder = new StringBuilder();
						builder.AppendFormat("Message: \"{0}\", code: {1}", fault.Message, fault.ErrorCode);

						if (fault.TraceText != null)
						{
							builder.AppendFormat(", trace: \"{0}\"", fault.TraceText);
						}

						if (fault.InnerFault != null)
						{
							builder.AppendFormat(", inner message: \"{0}\", inner code: {1}", fault.InnerFault.Message,
								fault.InnerFault.ErrorCode);

							if (fault.InnerFault.TraceText != null)
							{
								builder.AppendFormat(", trace: \"{0}\"", fault.InnerFault.TraceText);
							}
						}

						faultMessage = builder.ToString();
					}

					var response =
						new ExecuteBulkResponse
						{
							RequestType = request.GetType(),
							Response = bulkResponse.Response,
							ResponseType = bulkResponse.Response == null ? null : bulkResponse.Response.GetType(),
							Fault = fault,
							FaultMessage = faultMessage
						};
					responses[request] = response;
					perBulkResponses[request] = response;
				}

				bulkFinishHandler?.Invoke(i + 1, (int)batchCount, perBulkResponses);

				// break on error and no 'continue on error' option
				if (!isContinueOnError && (bulkResponses.IsFaulted || bulkResponses.Responses.Any(e => e.Fault != null)))
				{
					break;
				}
			}

			return responses;
		}

		public static void RunWorkflow(IOrganizationService service, Guid entityId, Guid workflowId)
		{
			service.Execute(
				new ExecuteWorkflowRequest
				{
					EntityId = entityId,
					WorkflowId = workflowId
				});
		}

		/// <summary>
		///     Checks whether the given FetchXML returns any records.
		///  The record's ID is added to the FetchXML is as a condition.
		/// </summary>
		public static bool IsConditionMet(IOrganizationService service, string fetchXml,
			EntityReference record, string orgId)
		{
			service.Require("service");
			fetchXml.RequireNotEmpty("fetchXml");
			record.Require("record");

			var primaryIdName = MetadataHelpers.GetEntityAttributes(service, record.LogicalName, orgId,
				MetadataHelpers.EntityAttribute.PrimaryIdAttribute).PrimaryIdAttribute;
			var finalFetchXml = string.Empty;

			var querySplit = fetchXml.Split(new[] { "</entity>" }, StringSplitOptions.None);

			finalFetchXml += querySplit[0];
			finalFetchXml += "<filter type='and'> ";
			finalFetchXml += "<condition attribute='" + primaryIdName + "' operator='eq' value= '" + record.Id + "' /> ";
			finalFetchXml += "</filter>" + "</entity>";
			finalFetchXml += querySplit[querySplit.Length - 1];

			return service.RetrieveMultiple(new FetchExpression(finalFetchXml)).Entities.Any();
		}

		public static string BuildExceptionMessage(Exception ex, string preMessage = null, bool isUseExStackTrace = false, int depth = 0)
		{
			return ex.BuildExceptionMessage(preMessage, isUseExStackTrace, depth);
		}

		public static string BuildFaultMessage(OrganizationServiceFault fault, int depth)
		{
			return fault.BuildFaultMessage(depth);
		}

		public static InvalidPluginExecutionException BuildInvalidPluginExecException(Exception ex, string preMessage = null)
		{
			preMessage = (preMessage == null ? string.Empty : preMessage + " ") +
				"<div style=\"display:none\">Exception: " + ex.GetType() + " => \"" + ex.Message + "\"." +
				(ex.InnerException == null
					? string.Empty
					: " Inner exception: " + ex.InnerException.GetType() + " => \"" + ex.InnerException.Message + "\".") +
				"</div>";

			var message = "\nException: " + ex.GetType() + " => \"" + ex.Message + "\"." +
				"\nSource: " + ex.Source +
				"\n\n" + (ex.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmHelpers")) + "\n" +
				(ex.InnerException == null
					? string.Empty
					: "\n\nInner exception: " + ex.InnerException.GetType() + " => \"" +
						ex.InnerException.Message + "\"." +
						"\nSource: " + ex.InnerException.Source +
						"\n\n" + ex.InnerException.StackTrace + "\n");

			message = message
				.Replace("\"", "&quot;").Replace("'", "\\'").Replace("\n", "<br />").Replace("\\n", "<br />").Replace("\r",
					string.Empty);

			var script = "<br />" +
				"<button class=\"ms-crm-RefreshDialog-Button\" style=\"margin-right: 30px; margin-left: 8px;\"" +
				"onclick=\"" +
				" var w = window.open('', 'Error Details', 'height=100, width=600, toolbar=no, menubar=no, resizable=no, scrollbars=yes, location=no, directories=no, status=no');"
				+
				" parent.$(w.document.body).html('" + message + "');" +
				" w.document.title = 'Error Details';" +
				" parent.$(w.document.body).css({ 'color': 'blue', 'font-size': 13 });" +
				"\">More Details</button>"
				+ "<br />"
				+ "<br />";

			return new InvalidPluginExecutionException(preMessage + script, ex);
		}

		public static void LogAttributeValues(AttributeCollection attributes, Entity labelsRecord, CrmLog log,
			string logLabel = null)
		{
			attributes.Require("attributes");
			labelsRecord.Require("labelsRecord");
			log.Require("log");

			var attributesInfo = new StringBuilder();
			attributesInfo.Append("Attribute values (" + attributes.Count + "):");

			foreach (var attribute in attributes.OrderBy(pair => pair.Key))
			{
				var value = attribute.Value;

				if (value is OptionSetValue)
				{
					value = labelsRecord.FormattedValues.Contains(attribute.Key)
						? labelsRecord.FormattedValues[attribute.Key]
						: value;

					if (value is OptionSetValue)
					{
						value = ((OptionSetValue)value)?.Value;
					}
				}
				else if (value is EntityReference)
				{
					value = (labelsRecord.FormattedValues.Contains(attribute.Key)
						? labelsRecord.FormattedValues[attribute.Key]
						: ((EntityReference)value).Name) ?? value;

					if (value is EntityReference && value != null)
					{
						value = labelsRecord.GetAttributeValue<EntityReference>(attribute.Key)?.Name;
					}
				}
				else if (value is Money)
				{
					value = attribute.Value;
				}

				attributesInfo.Append("\r\n    \"" + attribute.Key + "\" => \"" + value + "\".");
			}

			log.Log(new LogEntry(logLabel ?? "Entity Object Values", LogLevel.Debug,
				labelsRecord.Id.ToString(), labelsRecord.LogicalName, attributesInfo.ToString()));
		}

		#region Relations helpers

		public static List<Entity> GetRelatedRecords(IOrganizationService service, EntityReference entity,
			MetadataHelpers.RelationType[] relationTypes, string orgId,
			FilterExpression filter = null, params string[] attributes)
		{
			var related = new List<Entity>();

			if (relationTypes == null || relationTypes.Length <= 0)
			{
				return related;
			}

			var relationAttributes =
				new[]
				{
					MetadataHelpers.RelationAttribute.SchemaName, MetadataHelpers.RelationAttribute.RelationshipType, MetadataHelpers.RelationAttribute.IntersectEntityName,
					MetadataHelpers.RelationAttribute.ReferencedEntity, MetadataHelpers.RelationAttribute.ReferencedAttribute,
					MetadataHelpers.RelationAttribute.ReferencingEntity, MetadataHelpers.RelationAttribute.ReferencingAttribute,
					MetadataHelpers.RelationAttribute.Entity1LogicalName, MetadataHelpers.RelationAttribute.Entity1IntersectAttribute,
					MetadataHelpers.RelationAttribute.Entity2LogicalName, MetadataHelpers.RelationAttribute.Entity2IntersectAttribute
				};

			var relations = MetadataHelpers
				.GetCustomRelationships(service, entity.LogicalName, relationTypes, relationAttributes, orgId)
				.Select(r => MetadataHelpers.BuildRelationMetadata(r,
					r.RelationshipType == RelationshipType.OneToManyRelationship
						? MetadataHelpers.RelationType.OneToManyRelationships
						: MetadataHelpers.RelationType.ManyToManyRelationships)).ToList();
			return GetRelatedRecordsInner(service, entity, relations, orgId, filter, attributes);
		}

		public static List<Entity> GetRelatedRecords(IOrganizationService service, EntityReference entity,
			string relationName, string orgId, FilterExpression filter = null, params string[] attributes)
		{
			service.Require(nameof(service));
			entity.Require(nameof(entity));
			relationName.RequireNotEmpty(nameof(relationName));

			var relation = MetadataHelpers.GetRelation(service, entity.LogicalName, relationName, orgId);
			return GetRelatedRecordsInner(service, entity, new List<RelationMetadata> { relation }, orgId,
				filter, attributes);
		}

		private static List<Entity> GetRelatedRecordsInner(IOrganizationService service, EntityReference entity,
			List<RelationMetadata> relations, string orgId, FilterExpression filter = null, params string[] attributes)
		{
			var related = new List<Entity>();

			var idFieldName = MetadataHelpers.GetEntityAttribute<string>(service, entity.LogicalName,
				MetadataHelpers.EntityAttribute.PrimaryIdAttribute, orgId);

			var manyToMany = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.ManyToManyRelationships);

			if (manyToMany.Any())
			{
				foreach (var rel in manyToMany)
				{
					var entity2Name = rel.Entity1Name == entity.LogicalName
						? rel.Entity2Name
						: rel.Entity1Name;
					var entity2Id = rel.Entity1Name == entity.LogicalName
						? rel.Entity2FieldName
						: rel.Entity1FieldName;
					var intersectEntity = rel.IntersectingEntityName;

					related.AddRange(GetRecords(entity, service, entity2Name, intersectEntity, entity2Id,
						entity2Id, idFieldName, -1, -1, filter, attributes));
				}
			}

			var oneToMany = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.OneToManyRelationships);

			if (oneToMany.Any())
			{
				foreach (var rel in oneToMany)
				{
					var entity2Name = rel.Entity2Name;
					var entity2LookupName = rel.Entity2FieldName;

					related.AddRange(GetRecords(entity, service, entity2Name, entity.LogicalName,
						entity2LookupName, idFieldName, idFieldName, -1, -1, filter, attributes));
				}
			}

			var manyToOne = relations.Where(relation => relation.Type == MetadataHelpers.RelationType.ManyToOneRelationships);

			if (manyToOne.Any())
			{
				foreach (var rel in manyToOne)
				{
					var entity2Name = rel.Entity1Name;
					var entity2LookupName = rel.Entity1FieldName;

					related.AddRange(GetRecords(entity, service, entity2Name, entity.LogicalName,
						entity2LookupName, idFieldName, idFieldName, -1, -1, filter, attributes));
				}
			}

			return related;
		}

		#endregion

		#region User helpers

		public static List<Guid> GetTeamMembers(IOrganizationService service, Guid teamId)
		{
			using (var svcContext = new OrganizationServiceContext(service))
			{
				return (from user in svcContext.CreateQuery("systemuser")
						join member in svcContext.CreateQuery("teammembership")
							on user["systemuserid"] equals member["systemuserid"]
						join teamQ in svcContext.CreateQuery("team")
							on member["teamid"] equals teamQ["teamid"]
						where teamQ["teamid"].Equals(teamId)
						select (Guid)user["systemuserid"]).ToList();
			}
		}

		public static List<Guid> GetQueueMembers(IOrganizationService service, Guid queueId)
		{
			using (var svcContext = new OrganizationServiceContext(service))
			{
				return (from user in svcContext.CreateQuery("systemuser")
						join member in svcContext.CreateQuery("queuemembership")
							on user["systemuserid"] equals member["systemuserid"]
						join queue in svcContext.CreateQuery("queue")
							on member["queueid"] equals queue["queueid"]
						where queue["queueid"].Equals(queueId)
						select (Guid)user["systemuserid"]).ToList();
			}
		}

		/// <summary>
		///     From the SDK: http://msdn.microsoft.com/en-us/library/hh670609.aspx <br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static int GetPreferredLangCode(IOrganizationService service, EntityReference record)
		{
			if (record.LogicalName == "systemuser")
			{
				var userSettingsQuery = new QueryExpression("usersettings");
				userSettingsQuery.ColumnSet.AddColumns("uilanguageid", "systemuserid");
				userSettingsQuery.Criteria.AddCondition("systemuserid", ConditionOperator.Equal, record.Id);
				var userSettings = service.RetrieveMultiple(userSettingsQuery);

				if (userSettings.Entities.Count > 0)
				{
					var code = (int)userSettings.Entities[0]["uilanguageid"];
					return code <= 0 ? 1033 : code;
				}
			}
			else if (record.LogicalName == "account" || record.LogicalName == "contact")
			{
				Entity result;

				result = service.Retrieve(record.LogicalName, record.Id, new ColumnSet("ldv_preferredcommunicationlanguage"));

				if (!result.Contains("ldv_preferredcommunicationlanguage"))
				{
					return 1033;
				}

				return ((OptionSetValue)result["ldv_preferredcommunicationlanguage"]).Value;
			}
			else
			{
				throw new NotSupportedException("Entity does not support a default language spec '" + record.LogicalName + "'.");
			}

			return 1033;
		}

		public static int GetUserTimeZoneBiasMinutes(IOrganizationService service, Guid userId)
		{
			return GetUsersTimeZoneBiasMinutes(service, userId).FirstOrDefault().Value;
		}

		public static IDictionary<Guid, int> GetUsersTimeZoneBiasMinutes(IOrganizationService service, params Guid[] userIds)
		{
			var query = new QueryExpression("usersettings");
			var filter = new FilterExpression(LogicalOperator.Or);

			foreach (var userId in userIds)
			{
				filter.AddCondition("systemuserid", ConditionOperator.Equal, userId);
			}

			query.ColumnSet = new ColumnSet("systemuserid", "timezonebias");
			query.Criteria.Filters.Add(filter);

			var userSettings = service.RetrieveMultiple(query).Entities;

			if (userSettings == null || userSettings.Count < userIds.Length
				|| userSettings.Any(settings => !settings.Contains("timezonebias")))
			{
				throw new Exception("Can't retrieve the settings of the users.");
			}

			return userSettings.ToDictionary(
				settings => settings.GetAttributeValue<Guid>("systemuserid"),
				settings => settings.GetAttributeValue<int>("timezonebias") * -1);
		}

		public static Guid? GetManagerId(IOrganizationService service, Guid userId)
		{
			var user = service.Retrieve("systemuser", userId, new ColumnSet("parentsystemuserid"));

			if (!user.Contains("parentsystemuserid"))
			{
				throw new Exception("User record does not contain a manager.");
			}

			return ((EntityReference)user["parentsystemuserid"]).Id;
		}

		/// <summary>
		///     Validates that the owner can edit the record.
		/// </summary>
		/// <param name="targetRecord">The target record to check for access rights.</param>
		/// <param name="targetOwner">The owner to check the rights for.</param>
		public static bool CanUpdateRecord(IOrganizationService service, EntityReference targetRecord,
			EntityReference targetOwner)
		{
			// request user's access rights to current record
			var principalAccessRequest =
				new RetrievePrincipalAccessRequest
				{
					Principal = targetOwner,
					Target = targetRecord
				};

			// response will contain AccessRights mask, like AccessRights.WriteAccess | AccessRights.ReadAccess | ...
			var principalAccessResponse = (RetrievePrincipalAccessResponse)service.Execute(principalAccessRequest);

			// if user can't edit record
			if ((principalAccessResponse.AccessRights & AccessRights.WriteAccess) != AccessRights.WriteAccess)
			{
				return false;
			}

			return true;
		}

		#endregion

		#region Placeholder parsers

		public static string ParseAttributeVariables(IOrganizationService service, string rawText,
			EntityReference recordRef, Guid userIdForTimeZone, string orgId,
			IDictionary<string, string> cachedValues = null, string placeholderLabel = null)
		{
			service.Require(nameof(service));
			recordRef.Require(nameof(recordRef));
			orgId.RequireNotEmpty(nameof(orgId));

			var record = service.Retrieve(recordRef.LogicalName, recordRef.Id, new ColumnSet(true));
			return ParseAttributeVariables(service, rawText, record, userIdForTimeZone, orgId,
				cachedValues, placeholderLabel);
		}

		/// <summary>
		///     Replaces all placeholders with their values. Traverses lookups and evaluates conditions.
		/// </summary>
		/// <param name="record">
		///     The record whose values will be used to replace the placeholders.
		///     All attributes in This record should be fully loaded.
		/// </param>
		public static string ParseAttributeVariables(IOrganizationService service, string rawText,
			Entity record, Guid userIdForTimeZone, string orgId,
			IDictionary<string, string> cachedValues = null, string placeholderLabel = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			orgId.RequireNotEmpty(nameof(orgId));

			if (string.IsNullOrEmpty(rawText))
			{
				return string.Empty;
			}

			cachedValues = cachedValues ?? new Dictionary<string, string>();
			var placeholderGuards = BuildPlaceholderGuards(record, placeholderLabel);

			var rawMatches = Regex.Matches(rawText,
				@"{(?:((?>(?<c1>{)|[^{}]+?|(?<-c1>}))+?(?(c1)(?!))\?\?(?>(?<c2>{)|[^{}]+?|(?<-c2>}))+(?(c2)(?!))::(?>(?<c3>{)|[^{}]+?|(?<-c3>}))+?(?(c3)(?!)))|((?>(?<c2>{)|[^{}]+?|(?<-c2>}))+(?(c2)(?!))))}");
			var matchesList = new List<Match>();

			foreach (Match match in rawMatches)
			{
				matchesList.Add(match);
			}

			// let's make sure that we only parse the outermost placeholders first
			var qualifiedMatches = matchesList.Where(m => matchesList.All(m2 =>
				((m.Index <= m2.Index && m.Index + m.Length <= m2.Index) || m.Index >= m2.Index + m2.Length)
					|| (m.Index <= m2.Index && m.Index + m.Length >= m2.Index + m2.Length)))
				.Select(m => m.Index).ToArray();

			var parsedVars = Regex.Replace(
				rawText,
				@"{" + placeholderGuards +
					@"(?:(?:((?>(?<c1>{)|[^{}]+?|(?<-c1>}))*?)(?(c1)(?!))\?\?((?>(?<c2>{)|[^{}]+?|(?<-c2>}))*)(?(c2)(?!))::((?>(?<c3>{)|[^{}]+?|(?<-c3>}))*?)(?(c3)(?!)))|((?>(?<c2>{)|[^{}]+?|(?<-c2>}))+)(?(c2)(?!)))"
					+
					"}",
				match =>
				{
					if (!match.Success || !qualifiedMatches.Contains(match.Index))
					{
						return match.Value;
					}

					var predicate = match.Groups[1].Value;
					var trueValue = match.Groups[2].Value;
					var falseValue = match.Groups[3].Value;

					if (predicate.IsEmpty())
					{
						return ParseAttributeVariable(service, $"{{{match.Groups[4].Value}}}", record,
							userIdForTimeZone, orgId, cachedValues, placeholderLabel);
					}

					var predicateMatch = Regex.Match(predicate,
						@"^((?>(?<c1>{)|[^{}]+?|(?<-c1>}))*?)(?(c1)(?!))(?:(==|[<>]=?|!=)((?>(?<c2>{)|[^{}]+|(?<-c2>}))*?)(?(c2)(?!)))?$");

					var conditionLeft = predicateMatch.Groups[1].Value;
					bool isTrue;
					var parsedConditionLeft = ParseAttributeVariables(service, conditionLeft, record,
						userIdForTimeZone, orgId, cachedValues, placeholderLabel);
					parsedConditionLeft = string.IsNullOrWhiteSpace(parsedConditionLeft) ? null : parsedConditionLeft;

					if (predicateMatch.Groups[2].Value.IsNotEmpty() && predicateMatch.Groups[3].Value.IsNotEmpty())
					{
						var comparator = predicateMatch.Groups[2].Value;
						var conditionRight = predicateMatch.Groups[3].Value;
						var parsedConditionRight = ParseAttributeVariables(service, conditionRight, record,
							userIdForTimeZone, orgId, cachedValues, placeholderLabel);
						parsedConditionRight = string.IsNullOrWhiteSpace(parsedConditionRight) ? null : parsedConditionRight;

						var comparison = CompareValues(parsedConditionLeft, parsedConditionRight);

						switch (comparator)
						{
							case "==":
								isTrue = comparison == 0;
								break;
							case "<":
								isTrue = comparison < 0;
								break;
							case "<=":
								isTrue = comparison <= 0;
								break;
							case ">":
								isTrue = comparison > 0;
								break;
							case ">=":
								isTrue = comparison >= 0;
								break;
							case "!=":
								isTrue = comparison != 0;
								break;
							default:
								throw new Exception($"'{predicateMatch.Value}' is in an invalid format.");
						}
					}
					else
					{
						isTrue = parsedConditionLeft != null;
					}

					return isTrue ? trueValue : falseValue;
				});

			return parsedVars == rawText
				? parsedVars
				: ParseAttributeVariables(service, parsedVars, record, userIdForTimeZone, orgId,
					cachedValues, placeholderLabel);
		}

		/// <summary>
		///     Replaces all placeholders with their values. Traverses lookups.
		/// </summary>
		/// <param name="record">
		///     The record whose values will be used to replace the placeholders.
		///     All attributes in This record should be fully loaded.
		/// </param>
		public static string ParseAttributeVariable(IOrganizationService service, string rawText,
			Entity record, Guid userIdForTimeZone, string orgId,
			IDictionary<string, string> cachedValues = null, string placeholderLabel = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			orgId.RequireNotEmpty(nameof(orgId));

			if (string.IsNullOrEmpty(rawText))
			{
				return string.Empty;
			}

			cachedValues = cachedValues ?? new Dictionary<string, string>();
			var placeholderLabelRegex = placeholderLabel.IsNotEmpty() ? $"(?:!{placeholderLabel}!|(?!!.*?!))" : "";

			var parsedVariable = Regex.Replace(
				rawText, @"(?!{[0-9a-fA-F]{8}[-]?(?:[0-9a-fA-F]{4}[-]?){3}[0-9a-fA-F]{12}}){" + placeholderLabelRegex +
				@"((?>(?<c1>{)|[^{}]+?|(?<-c1>}))*?)(?(c1)(?!))(?:@((?>(?<c2>{)|[^{}]+?|(?<-c2>}))*)(?(c2)(?!)))?(?:(\$(?>(?<c3>{)|[^{}]+?|(?<-c3>}))*)(?(c3)(?!)))*}",
				match =>
				{
					if (match.Success)
					{
						var parsedInnerVariable = ParseAttributeVariables(service, match.Groups[1].Value, record,
							userIdForTimeZone, orgId, cachedValues, placeholderLabel);
						var parsedModifier = ParseAttributeVariables(service, match.Groups[2].Value, record,
							userIdForTimeZone, orgId, cachedValues, placeholderLabel);
						var parsedStringModifier = ParseAttributeVariables(service, match.Groups[3].Value, record,
							userIdForTimeZone, orgId, cachedValues, placeholderLabel);
						return GetFieldValueByPathAsString(service, parsedInnerVariable, parsedModifier, parsedStringModifier,
							record, userIdForTimeZone, orgId, cachedValues) ?? string.Empty;
					}

					return rawText;
				});

			return parsedVariable == rawText
				? parsedVariable
				: ParseAttributeVariable(service, parsedVariable, record, userIdForTimeZone, orgId,
					cachedValues, placeholderLabel);
		}

		private static string BuildPlaceholderGuards(Entity record, string placeholderLabel = null)
		{
			record.Require(nameof(record));
			var noLabelRegex = $"!meta.logicalname=={record.LogicalName}!|(?!!.*?!)";
			return $"(?:{(placeholderLabel.IsNotEmpty() ? $"!{placeholderLabel}!|{noLabelRegex}" : noLabelRegex)})";
		}

		private static int CompareValues(string first, string second)
		{
			var firstValue = GetTypedValue(first);
			var secondValue = GetTypedValue(second);

			if (firstValue is IComparable firstComparable && secondValue is IComparable secondComparable)
			{
				return (firstComparable is string ? secondComparable.ToString() : secondComparable)
					.CompareTo(secondComparable is string ? firstComparable.ToString() : firstComparable);
			}

			return firstValue == secondValue ? 0 : -1;
		}

		private static object GetTypedValue(string value)
		{
			value.Require(nameof(value));

			var isConverted = decimal.TryParse(value, out var parsedDecimalValue);

			if (isConverted)
			{
				return parsedDecimalValue;
			}

			isConverted = Guid.TryParse(value, out var parsedGuidValue);

			if (isConverted)
			{
				return parsedGuidValue;
			}

			isConverted = bool.TryParse(value, out var parsedBoolValue);

			if (isConverted)
			{
				return parsedBoolValue;
			}

			isConverted = DateTime.TryParse(value, out var parsedDateValue);

			if (isConverted)
			{
				return parsedDateValue;
			}

			return value;
		}

		public static string GetFieldValueByPathAsString(IOrganizationService service,
			string rawVariable, string modifier, string stringModifier,
			Entity record, Guid userIdForTimeZone, string orgId, IDictionary<string, string> cachedValues = null)
		{
			service.Require(nameof(service));
			rawVariable.Require(nameof(rawVariable));
			record.Require(nameof(record));

			cachedValues = cachedValues ?? new Dictionary<string, string>();
			var cacheKey = $"{record.LogicalName}:{record.Id}-{rawVariable}@{modifier}${stringModifier}";
			var isCached = cachedValues.TryGetValue(cacheKey, out var cachedMatch);

			if (isCached)
			{
				return cachedMatch;
			}

			var isModified = modifier.IsNotEmpty();

			// clean the variable from its delimiters
			var variable = rawVariable.TrimStart('.');

			// get all fields in the string
			var field = variable.Split('.');

			// get the first field to fetch
			var fieldName = field[0];

			if (fieldName == "recordid")
			{
				var recordId = record.Id.ToString();
				return cachedValues[cacheKey] = ProcessStringModifier(recordId, stringModifier);
			}

			if (fieldName == "recordurl")
			{
				return cachedValues[cacheKey] =
					ProcessStringModifier(GetRecordUrl(service, record.ToEntityReference(), orgId), stringModifier);
			}

			// remove the first field from the string
			variable = string.Join(".", field.Skip(1).ToArray()).Trim('.');

			var relationMatch = Regex.Match(fieldName,
				@"^>([^()]+?)(?:\((\*)?(?:\^(\w+?)(!)?)?(?:\|([^()]*?))?\))?(?:\(([^()]+?)(==|[<>]=?|!=)([^()]+?)\))?$");

			// relation drill-through
			if (relationMatch.Value.IsNotEmpty())
			{
				var relationName = relationMatch.Groups[1].Value;
				var isDistinct = relationMatch.Groups[2].Value == "*";
				var orderingField = relationMatch.Groups[3].Value;
				var isDescending = relationMatch.Groups[4].Value == "!";
				var separator = relationMatch.Groups[5].Value;
				var conditionLeft = relationMatch.Groups[6].Value;
				var comparator = relationMatch.Groups[7].Value;
				var conditionRight = relationMatch.Groups[8].Value;

				FilterExpression filter = null;

				if (conditionLeft.IsNotEmpty())
				{
					conditionRight = conditionRight.IsNotEmpty() ? conditionRight : null;

					if (comparator.IsNotEmpty() && conditionRight.IsNotEmpty())
					{
						ConditionOperator compareOp = ConditionOperator.Equal;

						switch (comparator)
						{
							case "==":
								compareOp = ConditionOperator.Equal;
								break;
							case "<":
								compareOp = ConditionOperator.LessThan;
								break;
							case "<=":
								compareOp = ConditionOperator.LessEqual;
								break;
							case ">":
								compareOp = ConditionOperator.GreaterThan;
								break;
							case ">=":
								compareOp = ConditionOperator.GreaterEqual;
								break;
							case "!=":
								compareOp = ConditionOperator.NotEqual;
								break;
							default:
								throw new Exception($"'{relationMatch.Value}' is in an invalid format.");
						}

						filter = new FilterExpression();
						filter.AddCondition(conditionLeft, compareOp, conditionRight);
					}
					else
					{
						filter = new FilterExpression();
						filter.AddCondition(conditionLeft, ConditionOperator.NotNull);
					}
				}

				// get field name in related entity
				field = variable.Split('.');
				fieldName = field[0];
				variable = string.Join(".", field.Skip(1).ToArray()).Trim('.');

				var records = GetRelatedRecords(service, record.ToEntityReference(), relationName, orgId,
					filter, new[] { fieldName, orderingField }.Where(f => f.IsNotEmpty()).Distinct().ToArray())
					.AsQueryable();

				if (orderingField.IsNotEmpty())
				{
					records = isDescending
						? records.OrderByDescending(
							r => GetTypedValue(GetAttributeStringValue(r.GetAttributeValue<object>(orderingField))))
						: records.OrderBy(r => GetTypedValue(GetAttributeStringValue(r.GetAttributeValue<object>(orderingField))));
				}

				var relationStrings = new List<string>();

				foreach (var relatedRecord in records)
				{
					// get the field value from the entity record
					var relatedValue = relatedRecord.GetAttributeValue<object>(fieldName);

					if (relatedValue == null)
					{
						continue;
					}

					if (variable.IsNotEmpty())
					{
						// if the field value is not a lookup, then we can't recurse
						var reference = relatedValue as EntityReference;

						if (reference == null)
						{
							throw new Exception($"Field \"{fieldName}\" is not a lookup.");
						}

						var refEntity =
							new Entity(reference.LogicalName)
							{
								Id = reference.Id
							};

						relationStrings.Add(GetFieldValueByPathAsString(service, variable, modifier, stringModifier, refEntity,
							userIdForTimeZone, orgId));
					}
					else
					{
						relationStrings.Add(GetAttributeStringValue(relatedValue));
					}
				}

				return string.Join(separator, isDistinct ? relationStrings.Distinct() : relationStrings);
			}

			// get the field value from the entity record
			var fieldValue = record.GetAttributeValue<object>(fieldName);

			// get the entity record
			record = fieldValue == null
				? service.Retrieve(record.LogicalName, record.Id, new ColumnSet(fieldName))
				: record;

			fieldValue = record.GetAttributeValue<object>(fieldName);

			if (fieldValue == null)
			{
				return cachedValues[cacheKey] = null;
			}

			// variable is recursive, so we need to go deeper through the lookup
			if (variable.IsNotEmpty())
			{
				// if the field value is not a lookup, then we can't recurse
				var reference = fieldValue as EntityReference;

				if (reference == null)
				{
					throw new Exception($"Field \"{fieldName}\" is not a lookup.");
				}

				var refEntity =
					new Entity(reference.LogicalName)
					{
						Id = reference.Id
					};

				return cachedValues[cacheKey] =
					GetFieldValueByPathAsString(service, variable, modifier, stringModifier, refEntity, userIdForTimeZone, orgId);
			}

			var result = string.Empty;

			if (fieldValue is string s)
			{
				result = s;
			}

			if (fieldValue is OptionSetValue value)
			{
				string label;

				if (isModified)
				{
					label = MetadataHelpers.GetOptionSetLabel(service, record.LogicalName, fieldName,
						value.Value, orgId, int.Parse(modifier))
						?? record.FormattedValues.FirstOrDefault(keyVal => keyVal.Key == fieldName).Value;
				}
				else
				{
					label = value.Value.ToString();
				}

				result = label ?? string.Empty;
			}

			if (fieldValue is DateTime time)
			{
				if (isModified)
				{
					var date = time.ConvertToCrmUserTimeZone(service, userIdForTimeZone);
					result = string.Format($"{{0:{modifier}}}", date);
				}
				else
				{
					result = time.ToString("yyyy-MM-ddTHH:mm:ss.fffZ");
				}
			}

			if (fieldValue is EntityReference fieldRef)
			{
				if (isModified)
				{
					result =
						fieldRef.Name ?? GetRecordName(service, fieldRef.LogicalName, fieldRef.Id, orgId);
				}
				else
				{
					result = fieldRef.Id.ToString().ToUpper();
				}
			}

			if (fieldValue is Guid fieldGuid)
			{
				result = fieldGuid.ToString().ToUpper();
			}

			if (fieldValue is int fieldInt)
			{
				result = fieldInt.ToString();
			}

			if (fieldValue is Money fieldMoney)
			{
				fieldValue = fieldMoney.Value;
			}

			var isConverted = decimal.TryParse(fieldValue.ToString(), out var parsedDecimalValue);
			var isModifierConverted = int.TryParse(modifier, out var precision);

			if (isConverted && isModifierConverted)
			{
				result = parsedDecimalValue.ToString($"0.{new string('#', precision)}");
			}

			if (result.IsEmpty())
			{
				result = fieldValue.ToString();
			}

			return cachedValues[cacheKey] = ProcessStringModifier(result, stringModifier);
		}

		private static string ProcessStringModifier(string input, string modifiers)
		{
			var result = input;

			if (input == null)
			{
				return result;
			}

			foreach (Match match in Regex.Matches(modifiers,
				@"\$(upper|lower|title|trim|trimstart|trimend|sub|padleft|padright|replace|length|regex)(?:\(([^$]*?)\))?(?::([^$]*))?"))
			{
				var modifier = match.Groups[1].Value;
				var regexSeparator = match.Groups[2].Value;
				var parameter = match.Groups[3].Value;

				Match parameterMatch;

				switch (modifier)
				{
					case "upper":
						result = result.ToUpper();
						break;
					case "lower":
						result = result.ToLower();
						break;
					case "title":
						result = result.ToTitleCase();
						break;
					case "length":
						result = result.Length.ToString();
						break;
					case "trim":
					case "trimstart":
					case "trimend":
						if (parameter.IsNotEmpty())
						{
							if (char.TryParse(parameter, out var trimChar))
							{
								switch (modifier)
								{
									case "trim":
										result = result.Trim(trimChar);
										break;
									case "trimstart":
										result = result.TrimStart(trimChar);
										break;
									case "trimend":
										result = result.TrimEnd(trimChar);
										break;
								}
							}
						}
						else
						{
							switch (modifier)
							{
								case "trim":
									result = result.Trim();
									break;
								case "trimstart":
									result = result.TrimStart();
									break;
								case "trimend":
									result = result.TrimEnd();
									break;
							}
						}

						break;
					case "sub":
						if (parameter.IsNotEmpty())
						{
							parameterMatch = Regex.Match(parameter, @"(\d+)(?:,(\d+))?");
							var startMatch = parameterMatch.Groups[1].Value;
							var start = startMatch.IsNotEmpty() ? int.Parse(parameterMatch.Groups[1].Value) : 0;
							var lengthMatch = parameterMatch.Groups[2].Value;
							var length = lengthMatch.IsNotEmpty() ? int.Parse(lengthMatch) : result.Length;
							result = result.Substring(start, length - start);
						}

						break;
					case "replace":
						if (parameter.IsNotEmpty())
						{
							parameterMatch = Regex.Match(parameter, @"^""((?:[^""]|\\"")+)""(?:,""((?:[^""]|\\"")*)""$)");
							var origValue = parameterMatch.Groups[1].Value.Replace("\\\"", "\"");
							var replaceValue = parameterMatch.Groups[2].Value.Replace("\\\"", "\"");
							result = result.Replace(origValue, replaceValue);
						}

						break;
					case "padleft":
					case "padright":
						parameterMatch = Regex.Match(parameter, @"(\d+)(?:,(.))?");
						var countMatch = parameterMatch.Groups[1].Value;
						var totalWidth = countMatch.IsNotEmpty() ? int.Parse(parameterMatch.Groups[1].Value) : 0;
						var charMatch = parameterMatch.Groups[2].Value;
						var character = charMatch.IsNotEmpty() ? char.Parse(charMatch) : '\0';

						if (character != '\0')
						{
							switch (modifier)
							{
								case "padleft":
									result = result.PadLeft(totalWidth, character);
									break;
								case "padright":
									result = result.PadRight(totalWidth, character);
									break;
							}
						}
						else
						{
							switch (modifier)
							{
								case "padleft":
									result = result.PadLeft(totalWidth);
									break;
								case "padright":
									result = result.PadRight(totalWidth);
									break;
							}
						}

						break;
					case "regex":
						if (regexSeparator.IsNotEmpty() && parameter.IsNotEmpty())
						{
							var groupsStrings = new List<string>();

							foreach (Match matchT in Regex.Matches(result, parameter))
							{
								var groups = matchT.Groups;

								for (var i = 1; i < groups.Count; i++)
								{
									groupsStrings.Add(groups[i].Value);
								}
							}

							result = string.Join(regexSeparator, groupsStrings);
						}

						break;
				}
			}

			return result;
		}

		public static T GetFieldValueByPath<T>(IOrganizationService service, EntityReference entityRef, string path,
			IDictionary<string, object> cachedValues = null)
		{
			service.Require(nameof(service));
			entityRef.Require(nameof(entityRef));
			path.RequireNotEmpty(nameof(path));

			cachedValues = cachedValues ?? new Dictionary<string, object>();

			var isCached = cachedValues.TryGetValue(path, out var cachedMatch);

			if (isCached)
			{
				return (T)cachedMatch;
			}

			var fieldValue = path;
			var pathQueue = new Queue<string>();

			foreach (var match in fieldValue.Split('.'))
			{
				pathQueue.Enqueue(match);
			}

			if (pathQueue.Count <= 0)
			{
				throw new FormatException("Poorly formatted path: '" + path + "'.");
			}

			var valueRecord = service.Retrieve(entityRef.LogicalName, entityRef.Id, new ColumnSet(pathQueue.Peek()));

			while (pathQueue.Count > 1)
			{
				var pathNode = pathQueue.Dequeue();
				var valueRef = valueRecord.Attributes.FirstOrDefault(pair => pair.Key == pathNode).Value as EntityReference;

				if (valueRef == null)
				{
					return (T)(cachedValues[path] = default(T));
				}

				valueRecord = service.Retrieve(valueRef.LogicalName, valueRef.Id, new ColumnSet(pathQueue.Peek()));
			}

			var field = pathQueue.Peek();
			return (T)(cachedValues[path] =
				service.Retrieve(valueRecord.LogicalName, valueRecord.Id, new ColumnSet(field)).GetAttributeValue<T>(field));
		}

		#endregion

		public static string GetRecordUrl(IOrganizationService service, EntityReference recordRef, string orgId)
		{
			recordRef.Require(nameof(recordRef));
			orgId.RequireNotEmpty(nameof(orgId));

			var baseUrl = GetGenericConfig(service, orgId).GetAttributeValue<string>("ldv_organisationbaseurl");
			baseUrl.RequireNotEmpty(nameof(baseUrl));

			return $"{baseUrl.Trim('/')}/main.aspx"
				+ $"?etc={MetadataHelpers.GetTypeCodeUsingEntityName(service, recordRef.LogicalName, orgId)}"
				+ $"&id=%7b{recordRef.Id}%7d"
				+ $"&pagetype=entityrecord";
		}

		public static string GetAttributeStringValue(object fieldValue)
		{
			if (fieldValue == null)
			{
				return null;
			}

			if (fieldValue is string s)
			{
				return s;
			}

			if (fieldValue is OptionSetValue value)
			{
				return value.Value.ToString();
			}

			if (fieldValue is DateTime time)
			{
				return time.ToString("yyyy-MM-ddTHH:mm:ss.fffZ");
			}

			if (fieldValue is EntityReference fieldRef)
			{
				return $"{fieldRef.LogicalName}:{fieldRef.Id.ToString().ToUpper()}";
			}

			if (fieldValue is Guid fieldGuid)
			{
				return fieldGuid.ToString().ToUpper();
			}

			if (fieldValue is int fieldInt)
			{
				return fieldInt.ToString();
			}

			if (fieldValue is Money fieldMoney)
			{
				return fieldMoney.Value.ToString();
			}

			return fieldValue.ToString();
		}

		private static IEnumerable<Entity> GetRecords(EntityReference entity, IOrganizationService service,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string intersectIdFieldName, int limit = -1, int page = -1,
			FilterExpression filter = null, params string[] attributes)
		{
			return RetrieveRecords(service, BuildRetrieveQuery(entity, fromEntityName, toEntityName,
				fromFieldName, toFieldName, intersectIdFieldName, filter, attributes), limit, page);
		}

		private static QueryExpression BuildRetrieveQuery(EntityReference entity,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string intersectIdFieldName, FilterExpression filter = null, params string[] attributes)
		{
			// create the query taking into account paging
			var query = new QueryExpression(fromEntityName);
			query.LinkEntities.Add(new LinkEntity(fromEntityName, toEntityName, fromFieldName, toFieldName, JoinOperator.Inner));
			query.LinkEntities[0].EntityAlias = "linkedEntityAlias";
			query.Criteria.AddCondition("linkedEntityAlias", intersectIdFieldName, ConditionOperator.Equal, entity.Id);

			if (filter != null)
			{
				query.Criteria.AddFilter(filter);
			}

			if (attributes.Length == 1 && attributes[0] == "*")
			{
				query.ColumnSet = new ColumnSet(true);
			}
			else if (attributes.Length > 0)
			{
				query.ColumnSet = new ColumnSet(attributes);
			}
			else
			{
				query.ColumnSet = new ColumnSet(false);
			}

			return query;
		}

		public static string SecureConnectionString(string connectionString)
		{
			return Regex
				.Replace(Regex
					.Replace(connectionString, @"Password\s*?=.*?(?:;{0,1}$|;)", "Password=********;")
					.Replace("\r\n", " "),
					@"\s+", " ")
				.Replace(" = ", "=");
		}

		public static IEnumerable<TEntity> ToEntity<TEntity>(this IEnumerable<Entity> entities) where TEntity : Entity
		{
			return entities.Select(e => e.ToEntity<TEntity>());
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class MetadataHelpers
	{
		private static readonly string[] nonStandard =
		{
			"applicationfile",
			"attachment", // Not included with CrmSvcUtil 6.0.0001.0061
			"authorizationserver", // Not included with CrmSvcUtil 6.0.0001.0061
			"businessprocessflowinstance",
			// Not included with CrmSvcUtil 2013  http://community.dynamics.com/crm/f/117/t/117642.aspx
			"businessunitmap", // Not included with CrmSvcUtil 2013
			"clientupdate", // Not included with CrmSvcUtil 2013
			"commitment", // Not included with CrmSvcUtil 2013
			"competitoraddress", // isn't include in CrmSvcUtil but it shows in the default solution
			"complexcontrol", // Not Included with CrmSvcUtil 2013
			"dependencynode", // Not Included with CrmSvcUtil 2013
			"displaystringmap", // Not Included with CrmSvcUtil 2013
			"documentindex", // Not Included with CrmSvcUtil 2013
			"emailhash", // Not Included with CrmSvcUtil 2013
			"emailsearch", // Not Included with CrmSvcUtil 2013
			"filtertemplate", // Not Included with CrmSvcUtil 2013
			"imagedescriptor", // Not included with CrmSvcUtil 2013
			"importdata", // Not included with CrmSvcUtil 6.0.0001.0061
			"integrationstatus", // Not included with CrmSvcUtil 6.0.0001.0061
			"interprocesslock", // Not included with CrmSvcUtil 6.0.0001.0061
			"multientitysearchentities", // Not included with CrmSvcUtil 6.0.0001.0061
			"multientitysearch", // Not included with CrmSvcUtil 6.0.0001.0061
			"notification", // Not included with CrmSvcUtil 6.0.0001.0061
			"organizationstatistic", // Not included with CrmSvcUtil 6.0.0001.0061
			"owner", // Not included with CrmSvcUtil 2013
			"partnerapplication", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalattributeaccessmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalobjectaccessreadsnapshot", // Not included with CrmSvcUtil 6.0.0001.0061
			"principalobjectaccess", // Not included with CrmSvcUtil 6.0.0001.0061
			"privilegeobjecttypecodes", // Not included with CrmSvcUtil 6.0.0001.0061
			"postregarding", // Not included with CrmSvcUtil 2013
			"postrole", // Not included with CrmSvcUtil 2013
			"subscriptionclients", // Not included with CrmSvcUtil 6.0.0001.0061
			"salesprocessinstance", // Not included with CrmSvcUtil 6.0.0001.0061
			"recordcountsnapshot", // Not included with CrmSvcUtil 6.0.0001.0061
			"replicationbacklog", // Not included with CrmSvcUtil 6.0.0001.0061
			"resourcegroupexpansion", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribboncommand", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribboncontextgroup", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbondiff", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbonrule", // Not included with CrmSvcUtil 6.0.0001.0061
			"ribbontabtocommandmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"roletemplate", // Not included with CrmSvcUtil 6.0.0001.0061
			"statusmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"stringmap", // Not included with CrmSvcUtil 6.0.0001.0061
			"sqlencryptionaudit",
			"subscriptionsyncinfo",
			"subscription", // Not included with CrmSvcUtil 6.0.0001.0061
			"subscriptiontrackingdeletedobject",
			"systemapplicationmetadata", // Not included with CrmSvcUtil 6.0.0001.0061
			"systemuserbusinessunitentitymap", // Not included with CrmSvcUtil 6.0.0001.0061
			"systemuserprincipals", // Not included with CrmSvcUtil 6.0.0001.0061
			"traceassociation", // Not included with CrmSvcUtil 6.0.0001.0061
			"traceregarding", // Not included with CrmSvcUtil 6.0.0001.0061
			"unresolvedaddress", // Not included with CrmSvcUtil 6.0.0001.0061
			"userapplicationmetadata", // Not included with CrmSvcUtil 6.0.0001.0061
			"userfiscalcalendar", // Not included with CrmSvcUtil 6.0.0001.0061
			"webwizard", // Not included with CrmSvcUtil 6.0.0001.0061
			"wizardaccessprivilege", // Not included with CrmSvcUtil 6.0.0001.0061
			"wizardpage", // Not included with CrmSvcUtil 6.0.0001.0061
			"workflowwaitsubscription", // Not included with CrmSvcUtil 6.0.0001.0061
			// the following cause duplicate errors in generated code
			"bulkdeleteoperation",
			"reportlink",
			"rollupjob"
		};

		public enum EntityAttribute
		{
			LogicalName,
			SchemaName,
			DisplayName,
			PrimaryIdAttribute,
			PrimaryNameAttribute,
			ObjectTypeCode,
			IsActivity,
			Keys
		}

		public enum FieldAttribute
		{
			OptionSet,
			DisplayName
		}

		public enum RelationAttribute
		{
			SchemaName,
			RelationshipType,
			ReferencedEntity,
			ReferencedAttribute,
			ReferencingEntity,
			ReferencingAttribute,
			IntersectEntityName,
			Entity1LogicalName,
			Entity1IntersectAttribute,
			Entity2LogicalName,
			Entity2IntersectAttribute
		}

		public enum RelationType
		{
			OneToManyRelationships,
			ManyToOneRelationships,
			ManyToManyRelationships
		}

		/// <summary>
		///     Checks whether the given field exists in the entity by its logical name.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static bool IsFieldExistInEntity(IOrganizationService service, string entityName, string fieldName, string orgId)
		{
			var cacheKey = $"LinDev.Common.IsFieldExistInEntity|{entityName}|{fieldName}";
			var isExist = CacheHelpers.GetFromMemCache<bool?>(cacheKey, orgId);

			if (isExist.HasValue)
			{
				return isExist.Value;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("Attributes");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange("LogicalName");

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, fieldName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Criteria = attributeFilter,
							Properties = attributeProperties
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var result = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest)).EntityMetadata;
			return CacheHelpers.AddToMemCache(cacheKey,
				result != null && result.Count > 0 && result.First().Attributes.Length > 0
					&& result.First().Attributes.Any(attribute => attribute.LogicalName == fieldName),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the names of all entities.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static IDictionary<string, string> GetEntityNames(IOrganizationService service, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetEntityNames";
			var entityNames = CacheHelpers.GetFromMemCache<IDictionary<string, string>>(cacheKey, orgId);

			if (entityNames != null)
			{
				return entityNames;
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				GetEntities(service, orgId, MetadataHelpers.EntityAttribute.LogicalName, MetadataHelpers.EntityAttribute.DisplayName)
					.Where(e => e.DisplayName?.UserLocalizedLabel?.Label != null)
					.OrderBy(e => e.LogicalName)
					.ToDictionary(e => e.LogicalName, e => e.DisplayName?.UserLocalizedLabel?.Label),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the given properties of all entities.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static List<EntityMetadata> GetEntities(IOrganizationService service, string orgId,
			params MetadataHelpers.EntityAttribute[] attributes)
		{
			return GetEntities(service, orgId, attributes.Select(attribute => attribute.ToString()).ToArray<string>());
		}

		/// <summary>
		///     Get the names of all entities.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static List<EntityMetadata> GetEntities(IOrganizationService service, string orgId, params string[] attributes)
		{
			var cacheKey = $"LinDev.Common.GetEntities|{attributes.Aggregate("", (a1, a2) => a1 + "," + a2)}";
			var entities = CacheHelpers.GetFromMemCache<List<EntityMetadata>>(cacheKey, orgId);

			if (entities != null)
			{
				return entities;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};

			if (attributes?.Any() == true)
			{
				entityProperties.PropertyNames.AddRange(attributes);
			}

			var logicalNameString = MetadataHelpers.EntityAttribute.LogicalName.ToString();

			if (attributes?.Contains(logicalNameString) != true)
			{
				entityProperties.PropertyNames.Add(logicalNameString);
			}

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest)).EntityMetadata
					.Where(entity =>
					{
						if (entity.LogicalName == null)
						{
							return false;
						}

						return !nonStandard.Contains(entity.LogicalName);
					}).ToList(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the entity meta data from the metadata cache.<br />
		///     Includes: LogicalName, DisplayName, PrimaryIdAttribute, PrimaryNameAttribute, Keys,
		///     Attributes, OneToManyRelationships, ManyToOneRelationships, ManyToManyRelationships<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static EntityMetadata GetEntity(IOrganizationService service, string logicalName, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetEntity|{logicalName}";
			var entity = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId);

			if (entity != null)
			{
				return entity;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("LogicalName", "DisplayName", "PrimaryIdAttribute", "PrimaryNameAttribute",
				"Keys", "Attributes", "OneToManyRelationships", "ManyToOneRelationships", "ManyToManyRelationships");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, logicalName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange("LogicalName", "DisplayName");

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("AttributeOf", MetadataConditionOperator.Equals, null));

			var keyProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			keyProperties.PropertyNames.AddRange("KeyAttributes");

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange("SchemaName",
				"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
				"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
				"Entity2LogicalName", "Entity2IntersectAttribute");

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Properties = attributeProperties,
							Criteria = attributeFilter
						},
					KeyQuery =
						new EntityKeyQueryExpression
						{
							Properties = keyProperties
						},
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Checks whether the entity exists in the metadata cache.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static bool IsEntityExist(IOrganizationService service, string logicalName, string orgId)
		{
			var cacheKey = $"LinDev.Common.IsEntityExist|{logicalName}";
			var isExist = CacheHelpers.GetFromMemCache<bool?>(cacheKey, orgId);

			if (isExist.HasValue)
			{
				return isExist.Value;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.Add("LogicalName");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, logicalName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.Any() == true,
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the value of an entity attribute from the metadata.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static T GetEntityAttribute<T>(IOrganizationService service, string entityName,
			MetadataHelpers.EntityAttribute attribute, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetEntityAttribute|{entityName}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties = new MetadataPropertiesExpression
			{
				AllProperties = false
			};
			entityProperties.PropertyNames.AddRange(attribute.ToString());

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals,
					entityName));

			var entityQueryExpression = new EntityQueryExpression
			{
				Criteria = entityFilter,
				Properties = entityProperties
			};

			var retrieveMetadataChangesRequest = new RetrieveMetadataChangesRequest
			{
				Query = entityQueryExpression,
				ClientVersionStamp = null
			};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();
			return CacheHelpers.AddToMemCache(cacheKey,
				(T)metadata?.GetType().GetProperty(attribute.ToString())?.GetValue(metadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the value of a list of entity attributes from the metadata.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static EntityMetadata GetEntityAttributes(IOrganizationService service, string entityName,
			string orgId, params MetadataHelpers.EntityAttribute[] attributes)
		{
			var cacheKey = $"LinDev.Common.GetEntityAttributes|{entityName}|"
				+ $"{attributes.Select(a => a.ToString()).Aggregate<string>((a1, a2) => a1 + "," + a2)}";
			var attributesCached = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId);

			if (attributesCached != null)
			{
				return attributesCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange(attributes.Select(a => a.ToString()));

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault(),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Gets the logical name using the entity's object type code.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static string GetEntityNameUsingTypeCode(IOrganizationService service, int typeCode, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetEntityNameUsingTypeCode|{typeCode}";
			var entityName = CacheHelpers.GetFromMemCache<string>(cacheKey, orgId);

			if (entityName != null)
			{
				return entityName;
			}

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(new MetadataConditionExpression("ObjectTypeCode",
				MetadataConditionOperator.Equals, typeCode));

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("LogicalName");

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			return CacheHelpers.AddToMemCache(cacheKey,
				((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault()?.LogicalName,
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Gets the entity's object type code using its logical name.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static int GetTypeCodeUsingEntityName(IOrganizationService service, string entityName,
			string orgId)
		{
			return GetEntityAttribute<int?>(service, entityName, MetadataHelpers.EntityAttribute.ObjectTypeCode, orgId) ?? 0;
		}

		/// <summary>
		///     Get the value of a field attribute from the metadata.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static T GetFieldAttribute<T>(IOrganizationService service, string entityName, string fieldName,
			MetadataHelpers.FieldAttribute attribute, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetFieldAttribute|{entityName}|{fieldName}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange("Attributes");

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
			attributeFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, fieldName));

			var attributeProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			attributeProperties.PropertyNames.AddRange(attribute.ToString());

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					AttributeQuery =
						new AttributeQueryExpression
						{
							Properties = attributeProperties,
							Criteria = attributeFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			AttributeMetadata fieldmetadata = null;

			if (metadata != null)
			{
				fieldmetadata = metadata.Attributes?.FirstOrDefault();
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				(T)fieldmetadata?.GetType().GetProperty(attribute.ToString())?.GetValue(fieldmetadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Get the properties of all relations of a given type in an the entity from the metadata cache.<br />
		///     Includes: "SchemaName", "ReferencedEntity", "ReferencedAttribute", "ReferencingEntity",
		///     "ReferencingAttribute", "IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
		///     "Entity2LogicalName", "Entity2IntersectAttribute"<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static IEnumerable<RelationMetadata> GetEntityRelations(IOrganizationService service, string entityName,
			MetadataHelpers.RelationType? type, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetEntityRelations|{entityName}|{type}";
			var metadata = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId);

			if (metadata == null)
			{
				var entityProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};

				if (type == null)
				{
					entityProperties.PropertyNames.AddRange(Enum.GetNames(typeof(MetadataHelpers.RelationType)));
				}
				else
				{
					entityProperties.PropertyNames.Add(type.ToString());
				}

				var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
				entityFilter.Conditions
					.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

				var relationProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				relationProperties.PropertyNames.AddRange("SchemaName",
					"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
					"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
					"Entity2LogicalName", "Entity2IntersectAttribute");

				var entityQueryExpression =
					new EntityQueryExpression
					{
						Criteria = entityFilter,
						Properties = entityProperties,
						RelationshipQuery =
							new RelationshipQueryExpression
							{
								Properties = relationProperties,
							}
					};

				var retrieveMetadataChangesRequest =
					new RetrieveMetadataChangesRequest
					{
						Query = entityQueryExpression,
						ClientVersionStamp = null
					};

				metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault();

				if (metadata == null)
				{
					return new RelationMetadata[0];
				}

				CacheHelpers.AddToMemCache(cacheKey, metadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
			}

			return BuildRelationMetadata(metadata);
		}

		/// <summary>
		///     Get the properties of the relation from the metadata cache.<br />
		///     Includes: "SchemaName", "ReferencedEntity", "ReferencedAttribute", "ReferencingEntity",
		///     "ReferencingAttribute", "IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
		///     "Entity2LogicalName", "Entity2IntersectAttribute"<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static RelationMetadata GetRelation(IOrganizationService service, string entityName, string relationName,
			string orgId)
		{
			var cacheKey = $"LinDev.Common.GetRelation|{entityName}|{relationName}";
			var metadata = CacheHelpers.GetFromMemCache<EntityMetadata>(cacheKey, orgId);

			if (metadata == null)
			{
				var entityProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				entityProperties.PropertyNames.AddRange(Enum.GetNames(typeof(MetadataHelpers.RelationType)));

				var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
				entityFilter.Conditions
					.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

				var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
				relationFilter.Conditions
					.Add(new MetadataConditionExpression("SchemaName", MetadataConditionOperator.Equals, relationName));

				var relationProperties =
					new MetadataPropertiesExpression
					{
						AllProperties = false
					};
				relationProperties.PropertyNames.AddRange("SchemaName",
					"ReferencedEntity", "ReferencedAttribute", "ReferencingEntity", "ReferencingAttribute",
					"IntersectEntityName", "Entity1LogicalName", "Entity1IntersectAttribute",
					"Entity2LogicalName", "Entity2IntersectAttribute");

				var entityQueryExpression =
					new EntityQueryExpression
					{
						Criteria = entityFilter,
						Properties = entityProperties,
						RelationshipQuery =
							new RelationshipQueryExpression
							{
								Properties = relationProperties,
								Criteria = relationFilter
							}
					};

				var retrieveMetadataChangesRequest =
					new RetrieveMetadataChangesRequest
					{
						Query = entityQueryExpression,
						ClientVersionStamp = null
					};

				metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
					.EntityMetadata?.FirstOrDefault();

				if (metadata == null)
				{
					return null;
				}

				CacheHelpers.AddToMemCache(cacheKey, metadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
			}

			return BuildRelationMetadata(metadata).FirstOrDefault();
		}

		/// <summary>
		///     Get the value of a relation attribute from the metadata cache.<br />
		///     Author: Ahmed Elsawalhy
		/// </summary>
		public static T GetRelationAttribute<T>(IOrganizationService service, string entityName, string relationName,
			MetadataHelpers.RelationType type, MetadataHelpers.RelationAttribute attribute, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetRelationAttribute|{entityName}|{relationName}|{type}|{attribute}";
			var attributeCached = CacheHelpers.GetFromMemCache<T>(cacheKey, orgId);

			if (attributeCached != null)
			{
				return attributeCached;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.Add(type.ToString());

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions
				.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
			relationFilter.Conditions
				.Add(new MetadataConditionExpression("SchemaName", MetadataConditionOperator.Equals, relationName));

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange(attribute.ToString());

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties,
							Criteria = relationFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			if (metadata == null)
			{
				return default(T);
			}

			RelationshipMetadataBase relationMetadata = null;

			if (metadata.OneToManyRelationships != null)
			{
				relationMetadata = metadata.OneToManyRelationships.FirstOrDefault();
			}

			if (metadata.ManyToOneRelationships != null)
			{
				relationMetadata = metadata.ManyToOneRelationships.FirstOrDefault();
			}

			if (metadata.ManyToManyRelationships != null)
			{
				relationMetadata = metadata.ManyToManyRelationships.FirstOrDefault();
			}

			return CacheHelpers.AddToMemCache(cacheKey,
				(T)relationMetadata?.GetType().GetProperty(attribute.ToString())?.GetValue(relationMetadata),
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		public static List<RelationshipMetadataBase> GetCustomRelationships(IOrganizationService service,
			string entityName, MetadataHelpers.RelationType[] types, MetadataHelpers.RelationAttribute[] attributes,
			string orgId)
		{
			var cacheKey = $"LinDev.Common.GetCustomRelationships|{entityName}|"
				+ $"{types.Select(t => t.ToString()).Aggregate<string>((t1, t2) => t1 + "," + t2)}"
				+ $"{attributes.Select(a => a.ToString()).Aggregate<string>((a1, a2) => a1 + "," + a2)}";
			var relations = CacheHelpers.GetFromMemCache<List<RelationshipMetadataBase>>(cacheKey, orgId);

			if (relations != null)
			{
				return relations;
			}

			var entityProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			entityProperties.PropertyNames.AddRange(types.Select(type => type.ToString()));

			var entityFilter = new MetadataFilterExpression(LogicalOperator.And);
			entityFilter.Conditions.Add(
				new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entityName));

			var relationFilter = new MetadataFilterExpression(LogicalOperator.And);
			relationFilter.Conditions
				.Add(new MetadataConditionExpression("IsCustomRelationship", MetadataConditionOperator.Equals, true));

			var relationProperties =
				new MetadataPropertiesExpression
				{
					AllProperties = false
				};
			relationProperties.PropertyNames.AddRange(attributes.Select(attribute => attribute.ToString()));
			if (!attributes.Contains(MetadataHelpers.RelationAttribute.RelationshipType))
			{
				relationProperties.PropertyNames.AddRange(MetadataHelpers.RelationAttribute.RelationshipType.ToString());
			}

			var entityQueryExpression =
				new EntityQueryExpression
				{
					Criteria = entityFilter,
					Properties = entityProperties,
					RelationshipQuery =
						new RelationshipQueryExpression
						{
							Properties = relationProperties,
							Criteria = relationFilter
						}
				};

			var retrieveMetadataChangesRequest =
				new RetrieveMetadataChangesRequest
				{
					Query = entityQueryExpression,
					ClientVersionStamp = null
				};

			var metadata = ((RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest))
				.EntityMetadata?.FirstOrDefault();

			var relationMetadata = new List<RelationshipMetadataBase>();

			if (metadata == null)
			{
				return relationMetadata;
			}

			if (metadata.OneToManyRelationships != null)
			{
				relationMetadata.AddRange(metadata.OneToManyRelationships);
			}

			if (metadata.ManyToOneRelationships != null)
			{
				relationMetadata.AddRange(metadata.ManyToOneRelationships);
			}

			if (metadata.ManyToManyRelationships != null)
			{
				relationMetadata.AddRange(metadata.ManyToManyRelationships);
			}

			return CacheHelpers.AddToMemCache(cacheKey, relationMetadata, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		public static string GetOptionSetLabel(IOrganizationService service, string entityName, string fieldName,
			int value, string orgId, int? language = null)
		{
			var label = GetFieldAttribute<OptionSetMetadata>(service, entityName, fieldName, MetadataHelpers.FieldAttribute.OptionSet,
				orgId)?.Options.FirstOrDefault(optionQ => optionQ.Value == value)?.Label;

			return language == null
				? label?.UserLocalizedLabel?.Label
				: label?.LocalizedLabels?.Where(l => l.LanguageCode == language).FirstOrDefault()?.Label;
		}

		public static IEnumerable<RelationMetadata> BuildRelationMetadata(EntityMetadata entityMetadata)
		{
			IEnumerable<RelationMetadata> relationMetadata = new RelationMetadata[0];

			if (entityMetadata.OneToManyRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.OneToManyRelationships
					.Select(m => BuildRelationMetadata(m, MetadataHelpers.RelationType.OneToManyRelationships))
					.Where(r => r != null));
			}

			if (entityMetadata.ManyToOneRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.ManyToOneRelationships
					.Select(m => BuildRelationMetadata(m, MetadataHelpers.RelationType.ManyToOneRelationships))
					.Where(r => r != null));
			}

			if (entityMetadata.ManyToManyRelationships?.Length > 0)
			{
				relationMetadata = relationMetadata.Union(entityMetadata.ManyToManyRelationships
					.Select(m => BuildRelationMetadata(m, MetadataHelpers.RelationType.ManyToManyRelationships))
					.Where(r => r != null));
			}

			return relationMetadata;
		}

		public static RelationMetadata BuildRelationMetadata(RelationshipMetadataBase relationMetadata,
			MetadataHelpers.RelationType type)
		{
			if (relationMetadata is OneToManyRelationshipMetadata relation1NTypeSpecific
				&& type == MetadataHelpers.RelationType.OneToManyRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relation1NTypeSpecific.SchemaName,
					Entity1Name = relation1NTypeSpecific.ReferencedEntity,
					Entity1FieldName = relation1NTypeSpecific.ReferencedAttribute,
					Entity2Name = relation1NTypeSpecific.ReferencingEntity,
					Entity2FieldName = relation1NTypeSpecific.ReferencingAttribute,
					Type = type
				};
			}

			if (relationMetadata is OneToManyRelationshipMetadata relationN1TypeSpecific
				&& type == MetadataHelpers.RelationType.ManyToOneRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relationN1TypeSpecific.SchemaName,
					Entity1Name = relationN1TypeSpecific.ReferencedEntity,
					Entity1FieldName = relationN1TypeSpecific.ReferencedAttribute,
					Entity2Name = relationN1TypeSpecific.ReferencingEntity,
					Entity2FieldName = relationN1TypeSpecific.ReferencingAttribute,
					Type = type
				};
			}

			if (relationMetadata is ManyToManyRelationshipMetadata relationNnTypeSpecific
				&& type == MetadataHelpers.RelationType.ManyToManyRelationships)
			{
				return new RelationMetadata
				{
					SchemaName = relationNnTypeSpecific.SchemaName,
					Entity1Name = relationNnTypeSpecific.Entity1LogicalName,
					Entity1FieldName = relationNnTypeSpecific.Entity1IntersectAttribute,
					Entity2Name = relationNnTypeSpecific.Entity2LogicalName,
					Entity2FieldName = relationNnTypeSpecific.Entity2IntersectAttribute,
					IntersectingEntityName = relationNnTypeSpecific.IntersectEntityName,
					Type = type
				};
			}

			return null;
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class ErrorHelpers
	{
		public static string BuildExceptionMessage(this Exception ex, string preMessage = null, bool isUseExStackTrace = false,
			int depth = 0)
		{
			if (ex == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = (preMessage == null ? string.Empty : preMessage + "\r\n")
				+ "- Exception: " + ex.GetType()
				+ "\r\n- Message: " + ex.Message
				+ (ex.Source == null ? string.Empty : "\r\n- Source: " + ex.Source)
				+ (ex.HelpLink == null ? string.Empty : "\r\n- Help link: " + ex.HelpLink);

			try
			{
				message += (ex.TargetSite == null ? string.Empty : "\r\n- Target site: " + ex.TargetSite);
			}
			catch
			{
				// ignored
			}

			message += $"\r\n- HResult: {ex.HResult}"
				+ (ex.StackTrace == null
					? string.Empty
					: "\r\n- Stack trace:"
						+ "\r\n" + (ex.StackTrace
							?? (isUseExStackTrace
								? string.Empty
								: Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmHelpers"))));

			if (ex is System.ServiceModel.FaultException<OrganizationServiceFault> fault
				&& fault.CreateMessageFault().HasDetail)
			{
				message += $"\r\n\r\n--- START ** ORG SRV FAULT ---\r\n"
					+ $"\r\n{fault.Detail.BuildFaultMessage(depth)}"
					+ $"\r\n\r\n--- END ** ORG SRV FAULT ---";
			}

			if (ex.InnerException != null)
			{
				message += $"\r\n\r\n----- START ** INNER EXCEPTION -----\r\n"
					+ $"\r\n{ex.InnerException.BuildExceptionMessage(null, true, depth)}"
					+ $"\r\n\r\n----- END ** INNER EXCEPTION -----";
			}

			return message;
		}

		public static string BuildFaultMessage(this OrganizationServiceFault fault, int depth)
		{
			if (fault == null || depth > 5)
			{
				return string.Empty;
			}

			depth++;

			var message = $"- Error: {fault.Message}"
				+ $"\r\n- Error code: {fault.ErrorCode}"
				+ $"\r\n- Timestamp: {fault.Timestamp}"
				+ $"\r\n- Activity ID: {fault.ActivityId}";

			var text = fault.TraceText;

			if (text.IsFilled())
			{
				message += $"\r\n- Trace text:\r\n{text}";
			}

			if (fault.ErrorDetails?.Any() == true)
			{
				message = fault.ErrorDetails.Aggregate($"{message}\r\n- Error details:",
					(current, errorDetail) =>
						current + $"\r\n({errorDetail.Key}, {errorDetail.Value})");
			}

			if (fault.InnerFault != null)
			{
				message += $"\r\n\r\n--- INNER ORG SRV FAULT ---\r\n"
					+ $"\r\n{fault.InnerFault.BuildFaultMessage(depth)}";
			}

			return message;
		}

		public static string ExtractErrorCode(this string message)
		{
			var code = new Regex(@"0x\d*").Match(message).Value;
			return code.IsHexErrorCode() ? code : null;
		}

		public static bool IsHexErrorCode(this string code)
		{
			return new Regex(@"^0x\d*$").IsMatch(code);
		}
	}

	/// <summary>
	///     credit: http://stackoverflow.com/a/961904/1919456 <br />
	///     Credit: http://stackoverflow.com/questions/19049514/strategy-for-logging-in-production-for-dynamics-crm-plugins
	///     <br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class PluginInfo
	{
		public static string GetPluginExecutionInfo(IOrganizationService organizationService, IExecutionContext context)
		{
			var contextTemp = context as IPluginExecutionContext;

			var lines =
				new List<string>
				{
					"MessageName: " + context.MessageName,
					"PrimaryEntityName: " + context.PrimaryEntityName,
					"PrimaryEntityId: " + context.PrimaryEntityId,
					"SecondaryEntityName: " + context.SecondaryEntityName,
					"BusinessUnitId: " + context.BusinessUnitId,
					"CorrelationId: " + context.CorrelationId,
					"Depth: " + context.Depth,
					"InitiatingUserId: " + context.InitiatingUserId,
					"UserId: " + context.UserId,
					"IsInTransaction: " + context.IsInTransaction,
					"IsolationMode: " + context.IsolationMode,
					"Mode: " + context.Mode,
					"OperationCreatedOn: " + context.OperationCreatedOn,
					"OperationId: " + context.OperationId,
					"Organization: " + context.OrganizationName + "(" + context.OrganizationId + ")"
				};


			if (contextTemp != null)
			{
				lines.Add("Stage: " + contextTemp.Stage);
			}

			AddEntityReference(lines, context.OwningExtension, "OwningExtension");
			
			ParameterCollection inputParams = null;

			try
			{
				inputParams = context.InputParameters;
			}
			catch
			{
				// ignored
			}

			if (inputParams != null)
			{
				AddParameters(organizationService, lines, inputParams, "Input Parameters");
			}

			AddParameters(organizationService, lines, context.OutputParameters, "Output Parameters");
			AddParameters(organizationService, lines, context.SharedVariables, "Shared Variables");
			AddEntityImages(organizationService, lines, context.PostEntityImages, "Post Entity Images");
			AddEntityImages(organizationService, lines, context.PreEntityImages, "Pre Entity Images");

			if (contextTemp != null)
			{
				lines.Add("Has Parent Context: " + (contextTemp.ParentContext != null));

				if (contextTemp.ParentContext != null)
				{
					lines.Add("-- Parent Context --");
					lines.Add(GetPluginExecutionInfo(organizationService, contextTemp.ParentContext));
				}
			}

			return string.Join(Environment.NewLine, lines);
		}

		private static void AddEntity(IOrganizationService service, List<string> nameValuePairs, Entity entity, string name)
		{
			if (entity != null)
			{
				nameValuePairs.Add($"** {name} **");
				nameValuePairs.AddRange(entity.Attributes
					.Select(att =>
						"    Entity[" + att.Key + "]: " +
							GetAttributeValue(service, entity.LogicalName, att.Key, att.Value)));
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}

		private static string GetAttributeValue(IOrganizationService organizationService, string logicalName, string key,
			object value)
		{
			if (value == null)
			{
				return "Null";
			}

			var type = value.GetType();

			if (type == typeof(OptionSetValue))
			{
				var retrieveOptionSetRequest =
					new RetrieveAttributeRequest
					{
						EntityLogicalName = logicalName,
						LogicalName = key,
						RetrieveAsIfPublished = true
					};

				var response = (RetrieveAttributeResponse)organizationService.Execute(retrieveOptionSetRequest);

				var metadata = response.AttributeMetadata as EnumAttributeMetadata;

				if (metadata != null)
				{
					var valueTemp = ((OptionSetValue)value).Value;
					return valueTemp + " (" +
						metadata.OptionSet.Options.First(option => option.Value == valueTemp).Label.UserLocalizedLabel.Label + ")";
				}
			}

			if (type != typeof(EntityReference))
			{
				return value.ToString();
			}

			var reference = (EntityReference)value;

			if (reference.LogicalName == null)
			{
				return value.ToString();
			}

			var primaryAttribute = ((RetrieveEntityResponse)organizationService
				.Execute(
					new RetrieveEntityRequest
					{
						EntityFilters = EntityFilters.Entity,
						LogicalName = reference.LogicalName
					})).EntityMetadata.PrimaryNameAttribute;

			return reference.Id + " (" +
				organizationService.Retrieve(reference.LogicalName, reference.Id, new ColumnSet(primaryAttribute))
					.GetAttributeValue<string>(primaryAttribute) + ")";
		}

		private static void AddEntityReference(ICollection<string> nameValuePairs, EntityReference entity, string name)
		{
			if (entity != null)
			{
				nameValuePairs.Add(name + ": " + entity.Name);
			}
		}

		private static void AddEntityImages(IOrganizationService organizationService, List<string> nameValuePairs,
			EntityImageCollection images, string name)
		{
			if (images != null && images.Count > 0)
			{
				nameValuePairs.Add("** " + name + " **");

				foreach (var image in images)
				{
					if (image.Value == null || image.Value.Attributes.Count == 0)
					{
						if (image.Value != null)
						{
							nameValuePairs.Add("    Image[" + image.Key + "] " + image.Value.ToEntityReference().Name + ": Empty");
						}
					}
					else
					{
						nameValuePairs.Add("*   Image[" + image.Key + "] " + image.Value.ToEntityReference().Name + "   *");
						nameValuePairs.AddRange(image.Value.Attributes
							.Select(att =>
								"        Entity[" + att.Key + "]: " +
									GetAttributeValue(organizationService, image.Value.ToEntityReference().LogicalName, att.Key, att.Value)));
					}
				}
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}

		private static void AddParameters(IOrganizationService service, List<string> nameValuePairs,
			ParameterCollection parameters, string name)
		{
			if (parameters != null && parameters.Count > 0)
			{
				nameValuePairs.Add("* " + name + " *");
				nameValuePairs.AddRange(parameters
					.Where(param => !(param.Value is Entity))
					.Select(param => "    Param[" + param.Key + "]: " + param.Value));

				foreach (var kv in parameters
					.Where(param => param.Value is Entity))
				{
					var entity = (Entity)kv.Value;
					AddEntity(service, nameValuePairs, entity,
						$"{kv.Key} {entity.ToEntityReference().Name}");
				}
			}
			else
			{
				nameValuePairs.Add(name + ": Empty");
			}
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class BpfHelpers
	{
		/// <summary>
		///     Returns all stages in the process, in order, with their names.<br />
		/// </summary>
		/// <param name="service">The service.</param>
		/// <param name="processId">The process identifier.</param>
		public static List<BpfStageInfo> GetStages(IOrganizationService service, Guid processId, string orgId)
		{
			var cacheKey = $"LinDev.Common.GetStages|{processId}";
			var process = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId)
				?? CacheHelpers.AddToMemCache(cacheKey,
					service.Retrieve("workflow", processId, new ColumnSet("xaml")),
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);

			if (!process.Contains("xaml"))
			{
				return null;
			}

			var doc = new XmlDocument();
			doc.LoadXml((string)process["xaml"]);

			var stepNodes = doc.SelectNodes("//*[local-name()='Workflow']/*[local-name()='ActivityReference']" +
				"/*[local-name()='ActivityReference.Properties']/*[local-name()='Collection']" +
				"/*[local-name()='ActivityReference']/*[local-name()='ActivityReference.Properties']");

			var stages = new List<BpfStageInfo>();

			if (stepNodes == null || stepNodes.Count <= 0)
			{
				return null;
			}

			for (var i = 0; i < stepNodes.Count; i++)
			{
				var idText = stepNodes[i].SelectSingleNode("*[local-name()='String' and @*[local-name()='Key']='StageId']");
				var id = idText?.InnerText;
				var labelNode =
					stepNodes[i].SelectSingleNode("*[local-name()='Collection']/*[local-name()='StepLabel']/@Description");
				var label = labelNode?.InnerText;

				if (id != null)
				{
					stages.Add(
						new BpfStageInfo
						{
							Id = Guid.Parse(id),
							Name = label,
							Index = i
						});
				}
			}

			return stages.Any() ? stages : null;
		}

		/// <summary>
		///     Fetches the BPF entity's record related to the given record as raw Entity object.
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">Target record with the process set.</param>
		/// <param name="processId">The process.</param>
		/// <param name="isIncludeStage">Include the current Stage ID and Traversed Path in the retrieved info.</param>
		/// <param name="primaryEntityPrefix">
		///     Prefix of the Primary Entity ID attribute.
		///     Default: "bpf", and for OoB Entities it's empty.
		/// </param>
		public static BpfRecord GetBpfRecord(IOrganizationService service, EntityReference record, Guid processId,
			string orgId, bool isIncludeStage = false, string primaryEntityPrefix = "bpf")
		{
			var processRecord = GetBpfRecordRaw(service, record, processId, orgId, isIncludeStage, primaryEntityPrefix);

			return
				new BpfRecord
				{
					LogicalName = processRecord.LogicalName,
					Id = processRecord.GetAttributeValue<Guid>("businessprocessflowinstanceid"),
					ProcessId = processRecord.GetAttributeValue<EntityReference>("processid").Id,
					StageId = processRecord.GetAttributeValue<EntityReference>("activestageid") == null
						? (Guid?)null
						: processRecord.GetAttributeValue<EntityReference>("activestageid").Id,
					TraversedPath = processRecord.GetAttributeValue<string>("traversedpath")
				};
		}

		/// <summary>
		///     Fetches the BPF entity's record related to the given record as raw Entity object.
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">Target record with the process set.</param>
		/// <param name="processId">The process.</param>
		/// <param name="isIncludeStage">Include the current Stage ID and Traversed Path in the retrieved info.</param>
		/// <param name="primaryEntityPrefix">
		///     Prefix of the Primary Entity ID attribute.
		///     Default: "bpf", and for OoB Entities it's empty.
		/// </param>
		public static Entity GetBpfRecordRaw(IOrganizationService service, EntityReference record, Guid processId,
			string orgId, bool isIncludeStage = false, string primaryEntityPrefix = "bpf")
		{
			var cacheKeyRecordName = $"Yagasoft.Common.GetBpfRecordRaw|{record.Id}|{processId}|processRecordName";
			var processRecordName = CacheHelpers.GetFromMemCache<string>(cacheKeyRecordName, orgId);

			var cacheKeyRecord = $"Yagasoft.Common.GetBpfRecordRaw|{record.Id}|{processId}|processRecord";
			var processRecord = CacheHelpers.GetFromMemCache<Entity>(cacheKeyRecord, orgId);

			if (!isIncludeStage && processRecord != null)
			{
				return processRecord;
			}

			using (var context = new OrganizationServiceContext(service) { MergeOption = MergeOption.NoTracking })
			{
				if (processRecordName == null)
				{
					// can't figure out the process record name except from the process's name in the DB
					processRecordName = CacheHelpers.AddToMemCache(cacheKeyRecordName,
						(from process in context.CreateQuery("workflow")
						 where (Guid)process["workflowid"] == processId
						 select (string)process["uniquename"]).FirstOrDefault(),
						CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);

					if (processRecordName == null)
					{
						throw new Exception($"Could not get the entity name of process: {processId}.");
					}
				}

				// get the special entity's record for this process and given target record
				processRecord =
					(from processRecordQ in context.CreateQuery(processRecordName)
					 where processRecordQ["processid"] == (object)processId
						 && processRecordQ[$"{(primaryEntityPrefix.IsFilled() ? $"{primaryEntityPrefix}_" : "")}{record.LogicalName}id"]
							 == (object)record.Id
					 select processRecordQ).FirstOrDefault();

				if (isIncludeStage)
				{
					return processRecord;
				}

				return CacheHelpers.AddToMemCache(cacheKeyRecord, processRecord,
					CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
			}
		}

		/// <summary>
		///     Returns the BPF Instance records. Logical Name of the Process Entity, and the Traversed Path are excluded.
		/// </summary>
		public static IEnumerable<BpfRecord> GetBpfInstances(IOrganizationService service, EntityReference record, string orgId,
			bool isIncludeStage = false)
		{
			return GetBpfInstancesRaw(service, record, orgId, isIncludeStage)?
				.Select(
					e =>
						new BpfRecord
						{
							Id = e.Id,
							ProcessId = e.GetAttributeValue<EntityReference>("processid")?.Id,
							StageId = e.GetAttributeValue<Guid?>("processstageid")
						});
		}

		/// <summary>
		///     Returns the BPF Instance records as raw Entity objects.
		/// </summary>
		public static IEnumerable<Entity> GetBpfInstancesRaw(IOrganizationService service, EntityReference record, string orgId,
			bool isIncludeStage = false)
		{
			var cacheKey = $"Yagasoft.Common.GetBpfInstancesRaw|{record.Id}";
			var instances = CacheHelpers.GetFromMemCache<IEnumerable<Entity>>(cacheKey, orgId);

			if (!isIncludeStage && instances != null)
			{
				return instances;
			}

			instances =
				((RetrieveProcessInstancesResponse)service.Execute(
					new RetrieveProcessInstancesRequest
					{
						EntityId = record.Id,
						EntityLogicalName = record.LogicalName
					})).Processes?.Entities.ToArray();

			if (isIncludeStage)
			{
				return instances;
			}

			return CacheHelpers.AddToMemCache(cacheKey, instances,
				CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
		}

		/// <summary>
		///     Returns the BPF Instance record of the given Process. The Traversed Path is excluded.
		/// </summary>
		public static BpfRecord GetBpfInstance(IOrganizationService service, EntityReference record, string processLogicalName,
			Guid processId, string orgId, bool isIncludeStage = false)
		{
			var instance = GetBpfInstances(service, record, orgId, isIncludeStage)?
				.FirstOrDefault(e => e.ProcessId == processId);

			if (instance != null)
			{
				instance.LogicalName = processLogicalName;
			}

			return instance;
		}

		/// <summary>
		///     Returns the BPF Instance record of the given Process as raw Entity object.
		/// </summary>
		public static Entity GetBpfInstanceRaw(IOrganizationService service, EntityReference record,
			Guid processId, string orgId, bool isIncludeStage = false)
		{
			return GetBpfInstancesRaw(service, record, orgId, isIncludeStage)
				.FirstOrDefault(e => e.GetAttributeValue<EntityReference>("processid")?.Id == processId);
		}

		public static Guid? GetActiveProcessId(IOrganizationService service, EntityReference record, string orgId)
		{
			return GetBpfInstances(service, record, orgId).FirstOrDefault()?.ProcessId;
		}

		public static Guid? GetActiveStageId(IOrganizationService service, EntityReference record, string orgId)
		{
			return GetBpfInstances(service, record, orgId, true).FirstOrDefault()?.StageId;
		}

		public static BpfStageRecord GetActiveStage(IOrganizationService service, EntityReference record, Guid? processId, string orgId,
			string primaryEntityPrefix = "bpf")
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processId.Require(nameof(processId));
			orgId.RequireNotEmpty(nameof(orgId));

			var bpfRecord = GetBpfRecordRaw(service, record, processId.GetValueOrDefault(), "123", true, primaryEntityPrefix);
			var stageId = bpfRecord.GetAttributeValue<EntityReference>("activestageid")?.Id;
			stageId.Require(nameof(stageId), $"Unable to find Stage ID in Process ({processId}) record ({bpfRecord.Id})"
				+ $" for record ({record.LogicalName}|{record.Id}).");
			var activePath = GetActivePathRaw(service, bpfRecord.Id).ToArray();
			var stage = activePath.FirstOrDefault(e => e.Id == stageId);
			stage.Require(nameof(stage), $"Unable to find Stage ({stageId}) info in Active Path of Process ({processId})"
				+ $" for record ({record.LogicalName}|{record.Id}).");
			var stageEntityName = stage?.GetAttributeValue<string>("primaryentitytypecode");
			var stageEntityRef = bpfRecord.GetAttributeValue<EntityReference>(
				$"{(primaryEntityPrefix.IsFilled() ? $"{primaryEntityPrefix}_" : "")}{stageEntityName}id");

			return
				new BpfStageRecord
				{
					Id = stageId.GetValueOrDefault(),
					StageRecord = stageEntityRef,
					ActivePath = activePath.Select(s => s.Id.ToString().ToLower()).StringAggregate(),
					TraversedPath = bpfRecord.GetAttributeValue<string>("traversedpath")
				};
		}

		public static void MoveStage(IOrganizationService service, EntityReference record, string processLogicalName, Guid processId, string orgId,
			bool moveBackwards = false, EntityReference stageRecordRef = null, string stageRecordLookupName = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processLogicalName.RequireNotEmpty(nameof(processLogicalName));
			orgId.RequireNotEmpty(nameof(orgId));

			var instance = GetBpfInstance(service, record, processLogicalName, processId, orgId);

			if (instance == null)
			{
				throw new Exception($"Can't find the BPF instance for process: {processId}.");
			}

			var activePath = GetActivePath(service, instance.Id).ToArray();

			Guid? targetStage = null;

			for (var i = 0; i < activePath.Length; i++)
			{
				if (activePath[i] != instance.StageId)
				{
					continue;
				}

				if (moveBackwards)
				{
					if (i <= 0)
					{
						throw new Exception("Can't move backwards from first stage in the process.");
					}

					targetStage = activePath[i - 1];
				}
				else
				{
					if (i >= activePath.Length - 1)
					{
						throw new Exception("Can't move forwards from last stage in the process.");
					}

					targetStage = activePath[i + 1];
				}

				break;
			}

			if (targetStage == null)
			{
				throw new Exception($"Can't find a stage to move to. Process: '{processId}', backwards: {moveBackwards}.");
			}

			var traversedPath = BuildTraversedPath(targetStage.Value, activePath);
			MoveToStage(service, record, targetStage.Value, instance, traversedPath, traversedPath, orgId, stageRecordRef, stageRecordLookupName);
		}

		/// <summary>
		///     Moves the process to the given stage.
		/// </summary>
		/// <param name="service">CRM service.</param>
		/// <param name="record">The target record to set the Stage in.</param>
		/// <param name="processLogicalName">The Logical Name of the BPF Entity.</param>
		/// <param name="processId">The process that includes the Stage.</param>
		/// <param name="stageId">The Stage.</param>
		/// <param name="stageRecordRef">The Stage record if multi-entity BPF.</param>
		/// <param name="stageRecordLookupName">The name of the Lookup in the Stage record Entity pointing to the main Entity.</param>
		public static void MoveToStage(IOrganizationService service, EntityReference record, string processLogicalName, Guid processId, Guid stageId,
			string orgId, EntityReference stageRecordRef = null, string stageRecordLookupName = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			processLogicalName.RequireNotEmpty(nameof(processLogicalName));
			orgId.RequireNotEmpty(nameof(orgId));

			var instance = GetBpfInstance(service, record, processLogicalName, processId, orgId, true);

			// first time the record is going to this process, so invoke a change so that CRM creates a BPF record first
			if (instance == null)
			{
				service.Update(
					new Entity(record.LogicalName, record.Id)
					{
						["processid"] = processId,
						["stageid"] = stageId
					});
				instance = GetBpfInstance(service, record, processLogicalName, processId, orgId, true);

				if (instance == null)
				{
					throw new Exception($"Can't find the BPF instance for Process: {processId}, for record: {record.Id}|{record.LogicalName}.");
				}
			}

			if (instance.StageId == null)
			{
				throw new Exception($"Can't find Active Stage ID in BPF record: {instance.Id},"
					+ $" for Process: {processId}, for record: {record.Id}|{record.LogicalName}.");
			}

			if (instance.StageId == stageId)
			{
				return;
			}

			if (instance == null)
			{
				throw new Exception($"Can't find the BPF instance for BPF record: {instance.Id},"
					+ $" for process: {processId}, for record: {record.Id}|{record.LogicalName}.");
			}

			var activePath = GetActivePath(service, instance.Id).ToArray();
			var oldTraversedPath = BuildTraversedPath(instance.StageId.Value, activePath);
			var newTraversedPath = BuildTraversedPath(stageId, activePath);
			MoveToStage(service, record, stageId, instance, oldTraversedPath, newTraversedPath, orgId, stageRecordRef, stageRecordLookupName);
		}

		public static void MoveToStage(IOrganizationService service, EntityReference record, Guid stageId, BpfRecord bpfInstanceRecord,
			string oldTraversedPath, string newTraversedPath, string orgId, EntityReference stageRecordRef = null,
			string stageRecordLookupName = null)
		{
			service.Require(nameof(service));
			record.Require(nameof(record));
			bpfInstanceRecord.Require(nameof(bpfInstanceRecord));
			bpfInstanceRecord.ProcessId.Require(nameof(bpfInstanceRecord.ProcessId));
			oldTraversedPath.RequireNotEmpty(nameof(oldTraversedPath));
			newTraversedPath.RequireNotEmpty(nameof(newTraversedPath));

			var oldPathLength = oldTraversedPath.Split(',').Length;
			var newPathLength = newTraversedPath.Split(',').Length;

			//if (Math.Abs(oldPathLength - newPathLength) > 1)
			//{
			//	MoveStage(service, record, bpfInstanceRecord.LogicalName, bpfInstanceRecord.ProcessId.GetValueOrDefault(), orgId,
			//		oldPathLength > newPathLength);
			//}

			var updatedProcessRecord =
				new Entity(bpfInstanceRecord.LogicalName)
				{
					Id = bpfInstanceRecord.Id,
					[$"bpf_{record.LogicalName}id"] = record,
					["activestageid"] = new EntityReference("processstage", stageId)
				};

			if (stageRecordRef != null)
			{
				updatedProcessRecord[$"bpf_{stageRecordRef.LogicalName}id"] = stageRecordRef;

				// before jumping into a stage entity record, it has to be related to the current record first, if not already so
				if (stageRecordLookupName.IsFilled())
				{
					service.Update(
						new Entity(stageRecordRef.LogicalName, stageRecordRef.Id) { [stageRecordLookupName] = record });
				}
			}

			service.Update(updatedProcessRecord);
		}

		public static IEnumerable<Guid> GetActivePath(IOrganizationService service, Guid instanceId)
		{
			return GetActivePathRaw(service, instanceId).Select(s => s.Id);
		}

		public static IEnumerable<Entity> GetActivePathRaw(IOrganizationService service, Guid instanceId)
		{
			return
				((RetrieveActivePathResponse)service.Execute(
					new RetrieveActivePathRequest
					{
						ProcessInstanceId = instanceId
					})).ProcessStages.Entities.ToArray();
		}

		public static string BuildTraversedPath(Guid stageId, IEnumerable<Guid> activePath)
		{
			var path = activePath.TakeWhile(s => s != stageId).Union(new[] { stageId }).Select(s => s.ToString()).StringAggregate();

			return path.IsFilled()
				? path
				: throw new Exception($"Couldn't find target stage '{stageId}' in the active path of the process.");
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static partial class SlaHelpers
	{
		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		/// Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="calendarName">Calendar name as it appears in CRM</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="duration">Duration after the start date in minutes</param>
		/// <param name="service">CRM service</param>
		/// <returns>DateTime after adding the duration to the start date</returns>
		public static DateTime GetDueDate(string calendarName, DateTime startDate, int duration,
			IOrganizationService service, string orgId)
		{
			var calendar = RetrieveCalender(calendarName, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, duration, calendar, holidays.ToArray(), service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		/// Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="calendarId">ID of calendar to use</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="duration">Duration after the start date in minutes</param>
		/// <param name="service">CRM service</param>
		/// <returns>DateTime after adding the duration to the start date</returns>
		public static DateTime GetDueDate(Guid calendarId, DateTime startDate, int duration,
			IOrganizationService service, string orgId)
		{
			var calendar = RetrieveCalender(calendarId, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, duration, calendar, holidays.ToArray(), service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		/// Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="calendarName">Calendar name as it appears in CRM</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="endDate">Date to measure to, in UTC</param>
		/// <param name="service">CRM service</param>
		/// <returns>Duration, in minutes, within the given range</returns>
		public static int GetDuration(string calendarName, DateTime startDate, DateTime endDate,
			IOrganizationService service, string orgId)
		{
			var calendar = RetrieveCalender(calendarName, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, endDate, calendar, holidays.ToArray(), service, orgId);
		}

		/// <summary>
		///     Get the date by adding duration to the start date within timeslots
		/// Credit: https://www.codeproject.com/Articles/1181377/Calculate-Due-Date-Based-on-the-Customer-Service-C
		/// Author: Ahmed Elsawalhy
		/// </summary>
		/// <param name="calendarId">ID of calendar to use</param>
		/// <param name="startDate">Date to measure from, in UTC</param>
		/// <param name="endDate">Date to measure to, in UTC</param>
		/// <param name="service">CRM service</param>
		/// <returns>Duration, in minutes, within the given range</returns>
		public static int GetDuration(Guid calendarId, DateTime startDate, DateTime endDate,
			IOrganizationService service, string orgId)
		{
			var calendar = RetrieveCalender(calendarId, service, orgId);
			var holidays = RetrieveHolidays(calendar.HolidayRef, service, orgId);
			return ProcessCalendar(startDate, endDate, calendar, holidays.ToArray(), service, orgId);
		}

		private static CrmCalendar RetrieveCalender(string calendarName, IOrganizationService service, string orgId)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveCalender|{calendarName}";
			var calendars = CacheHelpers.GetFromMemCache<DataCollection<Entity>>(cacheKey, orgId);

			if (calendars == null)
			{
				var query =
					new QueryExpression("calendar") { ColumnSet = new ColumnSet("holidayschedulecalendarid") };
				query.Criteria.AddCondition("name", ConditionOperator.Equal, calendarName);
				query.NoLock = true;
				calendars = service.RetrieveMultiple(query).Entities;

				CacheHelpers.AddToMemCache(cacheKey, calendars, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
			}

			return calendars.Select(calendar =>
				new CrmCalendar
				{
					Id = calendar.Id,
					HolidayRef = calendar.GetAttributeValue<EntityReference>("holidayschedulecalendarid")
				}).FirstOrDefault();
		}

		private static CrmCalendar RetrieveCalender(Guid calendarId, IOrganizationService service, string orgId)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveCalender|{calendarId}";
			var calendar = CacheHelpers.GetFromMemCache<Entity>(cacheKey, orgId);

			if (calendar == null)
			{
				calendar = service.Retrieve("calendar", calendarId, new ColumnSet("holidayschedulecalendarid"));
				CacheHelpers.AddToMemCache(cacheKey, calendar, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
			}

			return
				new CrmCalendar
				{
					Id = calendar.Id,
					HolidayRef = calendar.GetAttributeValue<EntityReference>("holidayschedulecalendarid")
				};
		}

		private static DateTime ProcessCalendar(DateTime startDate, int duration, CrmCalendar calendar, Holiday[] holidays,
			IOrganizationService service, string orgId)
		{
			DateTime? targetDate = null;
			var defaultTarget = DateTime.UtcNow.AddMinutes(duration);


			while (targetDate == null)
			{
				var timeSlots = RetrieveCalendarTimeSlots(calendar.Id, service, orgId, startDate);
				var availableSlots = GetAvailableTimeSlots(timeSlots, holidays).ToArray();

				foreach (var slot in availableSlots.Where(s => s.End > startDate))
				{
					var slotStart = slot.Start >= startDate ? slot.Start : startDate;
					var slotEnd = slot.End;
					var slotDuration = (int)((slotEnd - slotStart)?.TotalMinutes).GetValueOrDefault();

					// startDate was at the slot's end, or startDate was after the slot's end
					if (slotDuration <= 0)
					{
						continue;
					}

					if (slotDuration <= duration)
					{
						duration -= slotDuration;
						continue;
					}

					// something is wrong, assign default target date
					targetDate = slotStart?.AddMinutes(duration);
					break;
				}

				// duration > available slots
				if (targetDate == null)
				{
					var slotsEnd = timeSlots.LastOrDefault()?.End;

					// something is wrong, exit
					if (slotsEnd == null)
					{
						targetDate = defaultTarget;
					}
					else
					{
						// get more slots from CRM
						startDate = slotsEnd.Value;
					}
				}
			}

			return targetDate.Value;
		}

		private static int ProcessCalendar(DateTime startDate, DateTime endDate, CrmCalendar calendar, Holiday[] holidays,
			IOrganizationService service, string orgId)
		{
			var timeSlots = RetrieveCalendarTimeSlots(calendar.Id, service, orgId, startDate, endDate);
			var availableSlots = GetAvailableTimeSlots(timeSlots, holidays).ToArray();

			return
				(from slot in availableSlots.Where(s => s.End > startDate)
				 let slotStart = slot.Start >= startDate ? slot.Start : startDate
				 let slotEnd = slot.End <= endDate ? slot.End : endDate
				 let slotDuration = (int)Math.Round(((slotEnd - slotStart)?.TotalMinutes).GetValueOrDefault())
				 where slotDuration > 0
				 select slotDuration).Sum();
		}

		private static IEnumerable<Holiday> RetrieveHolidays(EntityReference holidayRef, IOrganizationService service, string orgId)
		{
			var cacheKey = $"Yagasoft.Common.RetrieveHolidays|{holidayRef}";
			var rules = CacheHelpers.GetFromMemCache<DataCollection<Entity>>(cacheKey, orgId);

			if (rules == null && holidayRef != null)
			{
				rules = service.Retrieve(holidayRef.LogicalName, holidayRef.Id, new ColumnSet(true))
					.GetAttributeValue<EntityCollection>("calendarrules").Entities;
				CacheHelpers.AddToMemCache(cacheKey, rules, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
			}

			return holidayRef == null
				? new Holiday[0]
				: rules.Select(holidayCalrule =>
						new Holiday
						{
							Start = holidayCalrule.GetAttributeValue<DateTime>("effectiveintervalstart"),
							End = holidayCalrule.GetAttributeValue<DateTime>("effectiveintervalend"),
							TimeZoneCode = holidayCalrule.GetAttributeValue<int?>("timezonecode")
						});
		}

		private static TimeInfo[] RetrieveCalendarTimeSlots(Guid calendarId, IOrganizationService service, string orgId,
			DateTime startDate, DateTime? endDate = null)
		{
			startDate = startDate.Date;
			endDate = endDate?.AddDays(1).Date ?? startDate.AddDays(30);

			var cacheKey = $"Yagasoft.Common.RetrieveCalendarTimeSlots|{calendarId}|{startDate}|{endDate}";
			var slots = CacheHelpers.GetFromMemCache<TimeInfo[]>(cacheKey, orgId);

			if (slots == null)
			{
				slots = ((ExpandCalendarResponse)service.Execute(
					new ExpandCalendarRequest
					{
						CalendarId = calendarId,
						Start = startDate,
						End = endDate.Value
					})).result;
				CacheHelpers.AddToMemCache(cacheKey, slots, CrmHelpers.GetMetadataCacheExpiryDate(service, orgId), orgId);
			}

			return slots;
		}

		private static IEnumerable<TimeInfo> GetAvailableTimeSlots(TimeInfo[] timeSlots, IEnumerable<Holiday> holidays)
		{
			return
				from timeSlotQ in timeSlots
				where holidays?.Any(holiday => holiday.Start < timeSlotQ.Start && holiday.End > timeSlotQ.End) != true
				select timeSlotQ;
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public static class FetchXmlTriggerHelpers
	{
		/// <summary>
		/// Register steps to handle FetchXML condition changes.<br />
		/// If you only care about satisfaction of conditions, then only pass plugin configs for post-operations.<br />
		/// If you need to check for negative/dissatisfaction of conditions, use pre and post-operations,
		/// passing the list of 'root' record IDs from the pre to the post plugin through the SharedVariables object.<br />
		/// You must mark the 'root' plugin, which can be common with other triggers.<br />
		/// 'GetFilteredTriggerConfigs' method can be used to get the serialised trigger config from the plugin config,
		/// which contains the FetchXML used for fetching the 'root' records.
		/// </summary>
		public static void RegisterTriggeringStep(IOrganizationService service, string id, string suffix, string fetchXml,
			TriggerConfigPlugin[] pluginConfigs, string orgId)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			id.RequireNotEmpty(nameof(id));
			fetchXml.RequireNotEmpty(nameof(fetchXml));

			var triggerConfigs = new List<TriggerConfig>();

			ParseConditionFields(service, $"{id}{(string.IsNullOrWhiteSpace(suffix) ? "" : $"-{suffix}")}",
				fetchXml, triggerConfigs, orgId);
			RegisterTriggeringStep(service, pluginConfigs, triggerConfigs, orgId);
		}

		public static void UnregisterTriggeringStep(IOrganizationService service, string id, string suffix, string fetchXml,
			TriggerConfigPlugin[] pluginConfigs, string orgId)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			id.RequireNotEmpty(nameof(id));
			fetchXml.RequireNotEmpty(nameof(fetchXml));

			var triggerConfigs = new List<TriggerConfig>();

			ParseConditionFields(service, $"{id}{(string.IsNullOrWhiteSpace(suffix) ? "" : $"-{suffix}")}",
				fetchXml, triggerConfigs, orgId);
			RegisterTriggeringStep(service, pluginConfigs, triggerConfigs, orgId, true);
		}

		public static IEnumerable<TriggerConfig> GetFilteredTriggerConfigs(string pluginConfig, params string[] fields)
		{
			return GetFilteredTriggerConfigs(ParseTriggerConfigs(pluginConfig), fields);
		}

		public static IEnumerable<TriggerConfig> GetFilteredTriggerConfigs(IEnumerable<TriggerConfig> triggerConfigs,
			params string[] fields)
		{
			return triggerConfigs.Where(t => fields.Contains("*") || fields.Intersect(t.Fields).Any());
		}

		private static void RegisterTriggeringStep(IOrganizationService service, TriggerConfigPlugin[] pluginConfigs,
			List<TriggerConfig> triggerConfigs, string orgId, bool isRemoveCurrent = false)
		{
			service.Require(nameof(service));
			pluginConfigs.Require(nameof(pluginConfigs));
			triggerConfigs.Require(nameof(triggerConfigs));

			foreach (var triggerConfig in triggerConfigs)
			{
				var id = triggerConfig.Id;
				var entityName = triggerConfig.EntityName;

				foreach (var pluginConfig in pluginConfigs)
				{
					if (triggerConfig.IsRootEntity != pluginConfig.IsRootEntity)
					{
						continue;
					}

					var step = GetStep(service, GetStepName(pluginConfig.Type, pluginConfig.Message, entityName));

					// get existing entity map from plugin configuration
					var stepConfig = step?.GetAttributeValue<string>("configuration");
					var parsedStepConfig = stepConfig == null
						? new List<TriggerConfig>()
						: ParseTriggerConfigs(stepConfig).Where(c => c.Id != id).ToList();

					foreach (var config in parsedStepConfig.Where(c => string.IsNullOrWhiteSpace(c.EntityName)))
					{
						config.EntityName = entityName;
					}

					if (!isRemoveCurrent)
					{
						parsedStepConfig.Add(triggerConfig);
					}

					if (pluginConfig.ExtraTriggerFields?.Any() == true)
					{
						foreach (var field in pluginConfig.ExtraTriggerFields)
						{
							triggerConfig.Fields.Add(field);
						}
					}

					var filteredStepConfigs = parsedStepConfig.Where(c => c.Fields.Any()).ToArray();

					var parsedStepConfigString = filteredStepConfigs
						.Select(c => $"{c.Id}|||{c.IsRootEntity}|||{c.Fields.StringAggregate()}"
							+ $"{(c.IsRootEntity ? "" : $"|||{c.FetchXml.StringAggregate("^^^")}")}")
						.Aggregate("", (c1, c2) => $"{c1};;;{c2}").Trim(',', ';');

					string[] filteringAttributes = null;

					if (pluginConfig.Message == "Update")
					{
						filteringAttributes = filteredStepConfigs.SelectMany(c => c.Fields).Distinct().ToArray();
					}

					RegisterStep(service, entityName, pluginConfig, parsedStepConfigString, orgId, filteringAttributes);
				}
			}
		}

		private static IEnumerable<TriggerConfig> ParseTriggerConfigs(string rawString)
		{
			rawString.RequireNotEmpty(nameof(rawString));

			return rawString.Decompress()
				.Split(new[] { ";;;" }, StringSplitOptions.RemoveEmptyEntries)
				.Select(c => c.Split(new[] { "|||" }, StringSplitOptions.RemoveEmptyEntries))
				.Where(c => c.Any() && !string.IsNullOrWhiteSpace(c[0]))
				.Select(c =>
					new TriggerConfig
					{
						Id = c[0],
						IsRootEntity = c.Length > 1 && bool.Parse(c[1]),
						Fields = c.Length > 2 ? new HashSet<string>(c[2].Split(',')) : new HashSet<string>(),
						FetchXml = c.Length > 3
							? c[3].Split(new[] { "^^^" }, StringSplitOptions.RemoveEmptyEntries).ToList()
							: new List<string>()
					});
		}

		private static void ParseConditionFields(IOrganizationService service, string id, string fetchXml,
			List<TriggerConfig> triggerConfigs, string orgId)
		{
			fetchXml.RequireNotEmpty(nameof(fetchXml));
			triggerConfigs.Require(nameof(triggerConfigs));

			var doc = new XmlDocument();
			doc.LoadXml(fetchXml);

			var parentNodes = doc.SelectNodes("//entity")?.Cast<XmlNode>().ToList();

			if (parentNodes == null)
			{
				throw new FormatException("FetchXML is not properly formatted.");
			}

			var linkNodes = doc.SelectNodes("//link-entity")?.Cast<XmlNode>().ToList();

			if (linkNodes != null)
			{
				parentNodes.AddRange(linkNodes);
			}

			foreach (var parent in parentNodes)
			{
				var conditionNodes = parent?.SelectNodes("filter//condition")?.Cast<XmlNode>();

				if (conditionNodes == null)
				{
					continue;
				}

				foreach (var node in conditionNodes)
				{
					var entityName = parent.Attributes?["name"]?.Value;
					var attributeName = node.Attributes?["attribute"]?.Value;

					if (entityName == null || attributeName == null)
					{
						continue;
					}

					var isRoot = parent.Name == "entity";
					var triggerConfig = triggerConfigs
							.FirstOrDefault(c => c.IsRootEntity == isRoot && c.EntityName == entityName);

					if (triggerConfig == null)
					{
						triggerConfig =
							new TriggerConfig
							{
								Id = id,
								IsRootEntity = isRoot,
								EntityName = entityName,
								FetchXml = new List<string>(),
								Fields = new HashSet<string>()
							};
						triggerConfigs.Add(triggerConfig);
					}

					triggerConfig.Fields.Add(attributeName);

					var xmlParser = new XmlDocument();
					var primaryIdField = MetadataHelpers.GetEntityAttribute<string>(service, entityName,
						MetadataHelpers.EntityAttribute.PrimaryIdAttribute, orgId);

					xmlParser.LoadXml("<temp><filter>"
						+ $@"<condition attribute=""{primaryIdField}"" operator=""eq"" value=""{{{{recordId}}}}""/></filter></temp>");

					var tempXmlNodes = xmlParser.SelectSingleNode("/temp")?.ChildNodes.Cast<XmlNode>();
					var newXmlNodes = new List<XmlNode>();

					if (tempXmlNodes != null)
					{
						foreach (var tempNode in tempXmlNodes)
						{
							var newNode = parent.OwnerDocument?.ImportNode(tempNode, true);
							newXmlNodes.Add(newNode);

							if (newNode != null)
							{
								parent.AppendChild(newNode);
							}
						}
					}

					var newFetchXml = doc.OuterXml;
					triggerConfig.FetchXml.Add(newFetchXml);

					foreach (var newXmlNode in newXmlNodes)
					{
						parent.RemoveChild(newXmlNode);
					}
				}
			}
		}

		private static void RegisterStep(IOrganizationService service, string entity, TriggerConfigPlugin pluginConfig,
			string unsecureConfig, string orgId, params string[] filteringAttributes)
		{
			service.Require(nameof(service));
			entity.RequireNotEmpty(nameof(entity));
			pluginConfig.Require(nameof(pluginConfig));

			var message = GetMessage(service, entity, pluginConfig.Message, orgId);

			if (message == null)
			{
				throw new Exception($"Couldn't find a message '{pluginConfig.Message}' for entity '{entity}'.");
			}

			var query =
				new QueryExpression("plugintype")
				{
					Distinct = true,
					NoLock = true,
					ColumnSet = new ColumnSet("name", "plugintypeid")
				};
			query.Criteria.AddCondition("name", ConditionOperator.Equal, pluginConfig.Type);

			var type = service.RetrieveMultiple(query).Entities
				.Select(e =>
					new
					{
						e.Id,
						Name = e.GetAttributeValue<string>("name")
					}).FirstOrDefault();

			if (type == null)
			{
				throw new Exception($"Couldn't find '{pluginConfig.Type}' plugin type.");
			}

			message.PluginTypeId = type.Id;
			message.TypeName = type.Name;

			var stepName = GetStepName(message.TypeName, message.MessageName, entity);
			var step = GetStep(service, stepName);

			if (string.IsNullOrWhiteSpace(unsecureConfig))
			{
				if (step != null)
				{
					service.Delete("sdkmessageprocessingstep", step.Id);
				}
			}
			else
			{
				step = step
					?? new Entity("sdkmessageprocessingstep")
					{
						["name"] = stepName,
						["rank"] = 999,
						["stage"] = new OptionSetValue((int)pluginConfig.Stage),
						["supporteddeployment"] = new OptionSetValue(0),
						["sdkmessageid"] = new EntityReference("sdkmessage", message.MessageId),
						["sdkmessagefilterid"] = new EntityReference("sdkmessagefilter", message.FilteredId),
						["eventhandler"] = new EntityReference("plugintype", message.PluginTypeId)
					};

				step["configuration"] = unsecureConfig.Compress();

				if (filteringAttributes?.Any() == true)
				{
					step["filteringattributes"] = filteringAttributes.Aggregate("", (f1, f2) => $"{f1},{f2}").Trim(',', ';');
				}

				if (pluginConfig.Mode == PluginMode.Asynchronous)
				{
					step["asyncautodelete"] = true;
				}

				step["mode"] = new OptionSetValue((int)pluginConfig.Mode);

				if (step.Id == Guid.Empty)
				{
					var stepId = service.Create(step);

					if (pluginConfig.IsPreImage || pluginConfig.IsPostImage)
					{
						RegisterImage(service, pluginConfig, stepId);
					}
				}
				else
				{
					service.Update(step);
				}
			}
		}

		private static void RegisterImage(IOrganizationService service, TriggerConfigPlugin pluginConfig, Guid stepId)
		{
			service.Require(nameof(service));
			pluginConfig.Require(nameof(pluginConfig));

			int imageType;

			if (pluginConfig.IsPreImage && !pluginConfig.IsPostImage)
			{
				imageType = 0;
			}
			else if (!pluginConfig.IsPreImage && pluginConfig.IsPostImage)
			{
				imageType = 1;
			}
			else if (pluginConfig.IsPreImage && pluginConfig.IsPostImage)
			{
				imageType = 2;
			}
			else
			{
				throw new ArgumentOutOfRangeException("ImageType", "Image type is not supported.");
			}

			var image =
				new Entity("sdkmessageprocessingstepimage")
				{
					["name"] = "image",
					["entityalias"] = "image",
					["imagetype"] = new OptionSetValue(imageType),
					["messagepropertyname"] = pluginConfig.Message == "Create" ? "Id" : "Target",
					["sdkmessageprocessingstepid"] = new EntityReference("sdkmessageprocessingstep", stepId)
				};
			service.Create(image);
		}

		private static SdkMessageInfo GetMessage(IOrganizationService service, string entityName, string messageName,
			string orgId)
		{
			service.Require(nameof(service));
			entityName.RequireNotEmpty(nameof(entityName));
			messageName.RequireNotEmpty(nameof(messageName));

			var query =
				new FetchExpression("<fetch no-lock='true' >" +
					"  <entity name='sdkmessage' >" +
					"    <attribute name='name' />" +
					"    <attribute name='sdkmessageid' />" +
					"    <filter>" +
					$"      <condition attribute='name' operator='eq' value='{messageName}' />" +
					"    </filter>" +
					"    <link-entity name='sdkmessagefilter' from='sdkmessageid' to='sdkmessageid' alias='messagefilter' >" +
					"      <attribute name='sdkmessagefilterid' />" +
					"      <filter>" +
					"        <condition attribute='primaryobjecttypecode' operator='eq'"
					+ $" value='{MetadataHelpers.GetTypeCodeUsingEntityName(service, entityName, orgId)}' />" +
					"      </filter>" +
					"    </link-entity>" +
					"  </entity>" +
					"</fetch>");

			var message = service.RetrieveMultiple(query).Entities
				.Select(e =>
					new SdkMessageInfo
					{
						MessageId = e.GetAttributeValue<Guid>("sdkmessageid"),
						MessageName = e.GetAttributeValue<string>("name"),
						FilteredId = (Guid)
							(e.GetAttributeValue<AliasedValue>("messagefilter.sdkmessagefilterid")?.Value ?? Guid.Empty)
					}).FirstOrDefault();

			if (message == null || message.MessageId == Guid.Empty || message.FilteredId == Guid.Empty)
			{
				throw new Exception($"Couldn't find {messageName} message for entity '{entityName}'.");
			}

			return message;
		}

		private static Entity GetStep(IOrganizationService service, string stepName)
		{
			service.Require(nameof(service));
			stepName.RequireNotEmpty(nameof(stepName));

			var query =
				new QueryExpression("sdkmessageprocessingstep")
				{
					NoLock = true,
					ColumnSet = new ColumnSet(true)
				};
			query.Criteria.AddCondition("name", ConditionOperator.Equal, stepName);
			return service.RetrieveMultiple(query).Entities.FirstOrDefault();
		}

		private static string GetStepName(string typeName, string messageName, string entityName)
		{
			var builder = new StringBuilder();
			builder.Append("FetchXmlTrigger: ");
			builder.Append(typeName);
			builder.Append(": ");
			builder.Append(messageName);
			builder.Append(" of ");
			builder.Append(entityName == "none" ? "any entity" : entityName);

			return builder.ToString();
		}
	}

	public class CacheParams
	{
		public string OrgId;
		public string CacheSuffix;
		public DateTime? CacheExpiryTarget;
	}

	public class SdkMessageInfo
	{
		public Guid MessageId;
		public Guid FilteredId;
		public string MessageName;
		public Guid PluginTypeId;
		public string TypeName;
	}

	public class TriggerConfig
	{
		public string Id;
		public bool IsRootEntity;
		public string EntityName;
		public HashSet<string> Fields;
		public List<string> FetchXml;
	}

	public class TriggerConfigPlugin
	{
		public string Type;
		public string Message;
		public bool IsRootEntity;
		public PluginStage Stage;
		public PluginMode Mode;
		public bool IsPreImage;
		public bool IsPostImage;
		public string[] ExtraTriggerFields;
	}

	public class CrmCalendar
	{
		public Guid Id;
		public EntityReference HolidayRef;
	}

	public class Holiday
	{
		public DateTime Start;
		public DateTime End;
		public int? TimeZoneCode;
	}

	public class RetrievePagingInfo
	{
		public string Cookie
		{
			get; set;
		}

		public int NextPage { get; set; } = 1;

		public int RecordCountLimit { get; set; } = -1;

		public bool IsMoreRecords { get; set; } = true;
	}

	public class BpfRecord
	{
		public Guid Id
		{
			get; set;
		}
		public string LogicalName
		{
			get; set;
		}
		public Guid? ProcessId
		{
			get; set;
		}
		public Guid? StageId
		{
			get; set;
		}
		public string TraversedPath
		{
			get; set;
		}
	}

	public class BpfStageRecord
	{
		public Guid Id { get; set; }
		public EntityReference StageRecord { get; set; }
		public string ActivePath { get; set; }
		public string TraversedPath { get; set; }
	}

	public class BpfStageInfo
	{
		public Guid Id
		{
			get; set;
		}

		public string Name
		{
			get; set;
		}

		public int Index
		{
			get; set;
		}
	}

	public class ExecuteBulkResponse
	{
		public OrganizationResponse Response
		{
			get; set;
		}

		public Type RequestType
		{
			get; set;
		}

		public Type ResponseType
		{
			get; set;
		}

		public OrganizationServiceFault Fault
		{
			get; set;
		}

		public string FaultMessage
		{
			get; set;
		}
	}

	public class EntityComparer : IEqualityComparer<Entity>
	{
		public bool Equals(Entity x, Entity y)
		{
			return x.Id == y.Id;
		}

		public int GetHashCode(Entity obj)
		{
			return obj.Id.GetHashCode();
		}
	}

	public class EntityRefComparer : IEqualityComparer<EntityReference>
	{
		public bool Equals(EntityReference x, EntityReference y)
		{
			return x.Id == y.Id;
		}

		public int GetHashCode(EntityReference obj)
		{
			return obj.Id.GetHashCode();
		}
	}

	public class RelationMetadata
	{
		public string SchemaName
		{
			get; set;
		}
		public string Entity1Name
		{
			get; set;
		}
		public string Entity1FieldName
		{
			get; set;
		}
		public string Entity2Name
		{
			get; set;
		}
		public string Entity2FieldName
		{
			get; set;
		}
		public MetadataHelpers.RelationType Type
		{
			get; set;
		}
		public string IntersectingEntityName
		{
			get; set;
		}
	}

	/// <summary>
	///     Unlike <see cref="Semaphore" />, this implementation ensures that holds are released in the order of acquiring the
	///     hold.
	///     It also implements <see cref="IDisposable" />, but in a reusable fashion; e.g:
	///     <code>	using (fifoSemaphore.GetPermit())
	/// 	{
	///  		// code ...
	///   	}
	///     </code>
	///     After exiting the 'using' block, <see cref="ReleasePermit" /> is called automatically.<br />
	///     Author: Ahmed Elsawalhy (Yagasoft)
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public sealed class FifoSemaphore : IDisposable
	{
		private readonly Queue<ManualResetEvent> threadLocksQueue = new Queue<ManualResetEvent>();

		private readonly int maxConcurrency;

		private readonly object lockObject = new object();
		private int currentRequests;

		public FifoSemaphore(int maxConcurrency)
		{
			this.maxConcurrency = maxConcurrency;
		}

		public void Dispose()
		{
			ReleasePermit();
		}

		/// <summary>
		///     Check how many permits have been requested before, and if the number is greater than the limit,
		///     hold this request until a permit elsewhere is released.
		/// </summary>
		public FifoSemaphore AcquirePermit()
		{
			lock (lockObject)
			{
				currentRequests++;

				// if the limit hasn't been reached yet, note it, and give permission
				if (currentRequests <= maxConcurrency)
				{
					return this;
				}
			}

			using (var newLock = new ManualResetEvent(false))
			{
				// we have to wait for a slot to open
				threadLocksQueue.Enqueue(newLock);
				newLock.WaitOne();
			}

			return this;
		}

		/// <summary>
		///     Release a permit, and release the hold on the next in line.
		/// </summary>
		public void ReleasePermit()
		{
			lock (lockObject)
			{
				// note the release
				currentRequests--;

				// give permission to the next in line
				if (threadLocksQueue.Any())
				{
					threadLocksQueue.Dequeue().Set();
				}
			}
		}
	}

	/// <summary>
	///     credits: http://joe-bq-wang.iteye.com/blog/1878940 <br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public sealed class QueuedLock : IDisposable
	{
		private readonly object innerLock;
		private volatile int ticketsCount;
		private volatile int ticketToRide;

		public QueuedLock()
		{
			innerLock = new object();
			ticketToRide = ticketsCount + 1;
		}

		public void Dispose()
		{
			Exit();
		}

		public QueuedLock Enter()
		{
			var myTicket = Interlocked.Increment(ref ticketsCount);
			Monitor.Enter(innerLock);

			while (true)
			{
				if (myTicket == ticketToRide)
				{
					return this;
				}

				Monitor.Wait(innerLock);
			}
		}

		public void Exit()
		{
			Interlocked.Increment(ref ticketToRide);
			Monitor.PulseAll(innerLock);
			Monitor.Exit(innerLock);
		}
	}

	/// <summary>
	///     credits: http://joe-bq-wang.iteye.com/blog/1878940<br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public class BlockingQueue<T> : BlockingCollection<T>
	{
		#region ctor(s)

		public BlockingQueue() : base(new ConcurrentQueue<T>())
		{ }

		public BlockingQueue(int maxSize) : base(new ConcurrentQueue<T>(), maxSize)
		{ }

		#endregion ctor(s)

		#region Methods

		/// <summary>
		///     Enqueue an Item
		/// </summary>
		/// <param name="item">Item to enqueue</param>
		/// <remarks>Blocks if the blocking queue is full</remarks>
		public void Enqueue(T item)
		{
			Add(item);
		}

		/// <summary>
		///     Dequeue an item
		/// </summary>
		/// <param name="timeout">[Optional] The number of milliseconds to timeout while waiting. Value of -1 is infinite wait.</param>
		/// <returns>Item dequeued</returns>
		/// <remarks>Blocks if the blocking queue is empty</remarks>
		/// <exception cref="TimeoutException">Timeout expired.</exception>
		public T Dequeue(TimeSpan? timeout = null)
		{
			if (timeout == null)
			{
				return Take();
			}

			try
			{
				return Take(new CancellationTokenSource(timeout.Value).Token);
			}
			catch (OperationCanceledException)
			{
				throw new TimeoutException($"Timeout while waiting for an item to be added to the queue (timeout: {timeout} ms).");
			}
		}

		public T Dequeue(CancellationTokenSource cancellationToken)
		{
			return Take(cancellationToken.Token);
		}

		/// <summary>
		///     Clears the queue of all items
		/// </summary>
		public void Clear()
		{
			while (this.Any())
			{
				Dequeue();
			}
		}

		#endregion Methods
	}

	/// <summary>
	///     Adds to the queue, up to the limit, after which it dequeues to keep the size within the limit.<br />
	///     credits: https://stackoverflow.com/a/5852926/1919456<br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public class FixedSizeQueue<T> : ICollection<T>, IEnumerable<T>, IEnumerable, ICollection
	{
		public virtual int Count => q.Count;
		public virtual object SyncRoot => throw new NotSupportedException();
		public virtual bool IsSynchronized => false;
		public virtual bool IsReadOnly => false;

		protected readonly ConcurrentQueue<T> q = new ConcurrentQueue<T>();
		protected virtual int limit { get; set; }

		public FixedSizeQueue(int limit)
		{
			limit.RequireAtLeast(1, nameof(limit));
			this.limit = limit;
		}

		public virtual void Enqueue(T obj)
		{
			q.Enqueue(obj);
			while (q.Count > limit && q.TryDequeue(out var _)) ;
		}

		public virtual T Dequeue()
		{
			q.TryDequeue(out var e);
			return e;
		}

		public virtual void Add(T item)
		{
			Enqueue(item);
		}

		public virtual void Clear()
		{
			while (q.Any())
			{
				Dequeue();
			}
		}

		public virtual bool Contains(T item)
		{
			return q.Contains(item);
		}

		public virtual void CopyTo(T[] array, int arrayIndex)
		{
			array.Require(nameof(array));
			q.CopyTo(array, arrayIndex);
		}

		public virtual bool Remove(T item)
		{
			throw new NotSupportedException();
		}

		public virtual void CopyTo(Array array, int index)
		{
			array.Require(nameof(array));
			((ICollection)this.ToList()).CopyTo(array, index);
		}

		public virtual IEnumerator<T> GetEnumerator()
		{
			return q.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	#endregion

	#region CrmLog

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	[DebuggerNonUserCode]
	public sealed class LogAttribute : Attribute
	{
	}

	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public sealed class NoLogAttribute : Attribute
	{
	}

	/// <summary>
	///     Receives log entries and saves them to CRM, disk, or output to console.<br />
	///     Author: Ahmed Elsawalhy<br />
	///     Version: 4.2.1
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public class CrmLog
	{
		[Flags]
		private enum LogModeInternal
		{
			None = 0,
			CrmLog = 1,
			TraceService = 1 << 1,
			File = 1 << 2,
			Console = 1 << 3
		}

		#region Fields

		private readonly string configMemCacheKey = $"CrmLoggerConfig";
		private readonly string orgId;
		private readonly bool isSandboxMode;
		private readonly bool isPlugin;
		private Entity parentLog;
		private bool exceptionThrown;
		private LogEntry exceptionLogEntry;
		private Queue<LogEntry> logQueue;
		private Queue<LogEntry> offlineQueue;
		private Stack<LogEntry> execSeqStack;
		private Stopwatch executionTimer;
		private Stack<Stopwatch> functionTimersStack;
		private Stack<int> durationsStack;
		private bool isAutoLogToConsole;
		private bool isParentCreated;
		private bool? isBulkPreviously;
		
		private LogModeInternal logModes;


		#endregion

		#region Constructors

		/// <summary>
		///     Constructor!
		/// </summary>
		/// <param name="maximumLevel">[Optional] The maximum logging level to use, above which, no logs will be saved</param>
		public CrmLog(LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
		{
			InitialiseLog(null, null, maximumLevel, callingFunction);
			logModes |= LogModeInternal.File;
		}

		/// <summary>
		///     Constructor!
		/// </summary>
		/// <param name="organizationService">The service to be used to flush the entries to CRM</param>
		/// <param name="maximumLevel">[Optional] The maximum logging level to use, above which, no logs will be saved</param>
		public CrmLog(IOrganizationService organizationService, LogLevel? maximumLevel = null,
			[CallerMemberName] string callingFunction = "")
		{
			logModes |= LogModeInternal.CrmLog;
			InitialiseLog(organizationService, null, maximumLevel, callingFunction);
		}

		/// <summary>
		///     Constructor!
		/// </summary>
		/// <param name="organizationService">The service to be used to flush the entries to CRM.</param>
		/// <param name="traceService">The Plugin Tracing service used to log to CRM.</param>
		/// <param name="userId">The ID of the user that is going to be set in the logs.</param>
		/// <param name="maximumLevel">[Optional] The maximum logging level to use, above which, no logs will be saved.</param>
		public CrmLog(IOrganizationService organizationService, ITracingService traceService, Guid userId,
			bool isTraceOnly = false, LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
		{
			UserId = userId;

			if (!isTraceOnly)
			{
				logModes |= LogModeInternal.CrmLog;
			}

			logModes |= LogModeInternal.TraceService;
			InitialiseLog(organizationService, traceService, maximumLevel, callingFunction);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="serviceProvider">The service provider from a plugin.</param>
		/// <param name="isTraceOnly">Excludes CRM Log feature.</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum level.</param>
		public CrmLog(IServiceProvider serviceProvider, bool isTraceOnly = false, LogLevel? maximumLevel = null,
			[CallerMemberName] string callingFunction = "")
		{
			serviceProvider.Require(nameof(serviceProvider));

			if (!isTraceOnly)
			{
				logModes |= LogModeInternal.CrmLog;
			}

			logModes |= LogModeInternal.TraceService;

			var context = (IPluginExecutionContext)serviceProvider.GetService(typeof(IPluginExecutionContext));
			UserId = context.InitiatingUserId;
			isSandboxMode = context.IsolationMode == 2;
			isPlugin = true;

			orgId = context.OrganizationId.ToString();
			configMemCacheKey += $"|{orgId}";

			var service = ((IOrganizationServiceFactory)serviceProvider.GetService(typeof(IOrganizationServiceFactory)))
				.CreateOrganizationService(null);
			var tracingService = (ITracingService)serviceProvider.GetService(typeof(ITracingService));

			InitialiseLog(service, tracingService, maximumLevel, callingFunction);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="activityContext">The activity context from a custom step.</param>
		/// <param name="isTraceOnly">Excludes CRM Log feature.</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum level.</param>
		public CrmLog(ActivityContext activityContext, bool isTraceOnly = false, LogLevel? maximumLevel = null,
			[CallerMemberName] string callingFunction = "")
		{
			activityContext.Require(nameof(activityContext));

			if (!isTraceOnly)
			{
				logModes |= LogModeInternal.CrmLog;
			}

			logModes |= LogModeInternal.TraceService;

			var context = activityContext.GetExtension<IWorkflowContext>();
			UserId = context.InitiatingUserId;
			isSandboxMode = context.IsolationMode == 2;
			isPlugin = true;

			orgId = context.OrganizationId.ToString();
			configMemCacheKey += $"|{orgId}";

			var service = activityContext.GetExtension<IOrganizationServiceFactory>().CreateOrganizationService(null);
			var tracingService = activityContext.GetExtension<ITracingService>();

			InitialiseLog(service, tracingService, maximumLevel, callingFunction);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="path">[OPTIONAL] The path.</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum level.</param>
		/// <param name="config">[OPTIONAL] Parameters to use in managing offline logging.</param>
		public CrmLog(string path = "", LogLevel? maximumLevel = null, FileConfiguration config = null,
			[CallerMemberName] string callingFunction = "")
		{
			logModes |= LogModeInternal.File;
			InitialiseLog(null, null, maximumLevel, callingFunction);
			InitOfflineLog(path, false, config);
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="CrmLog" /> class.
		/// </summary>
		/// <param name="isAutoLog">If 'true', automatically output log entries to the console.</param>
		/// <param name="maxLogLevel">[OPTIONAL] The maximum log level to output to console. Default is 'Info'.</param>
		public CrmLog(bool isAutoLog, LogLevel? maxLogLevel = null, [CallerMemberName] string callingFunction = "")
		{
			logModes |= LogModeInternal.File | LogModeInternal.Console;
			InitialiseLog(null, null, maxLogLevel, callingFunction);
			MaxConsoleLogLevel = maxLogLevel ?? LogLevel.Info;
			IsAutoLogToConsole = isAutoLog;
		}

		protected CrmLog()
		{
		}

		#endregion

		/// <summary>
		///     The end states of the program that contains the logging object
		/// </summary>
		public enum ExecutionEndState
		{
			Success = 0,
			Failure = 1
		}

		#region Instance variables

		public IOrganizationService OrganizationService
		{
			get; private set;
		}

		public ITracingService TraceService
		{
			get; private set;
		}

		public Guid UserId
		{
			get; private set;
		}

		public FileConfiguration Config
		{
			get; private set;
		}

		public LogLevel MaxLogLevel
		{
			get; private set;
		}

		public ExecutionEndState AssemblyExecutionState
		{
			get; private set;
		}

		public int CurrentEntryIndex
		{
			get; private set;
		}

		public DateTime LogStartDate
		{
			get; private set;
		}

		public bool ExecutionStarted
		{
			get; private set;
		}

		public string OfflinePath
		{
			get; private set;
		}

		public bool IsFailOver
		{
			get; private set;
		}

		public LogLevel MaxConsoleLogLevel
		{
			get; private set;
		}

		public bool IsAutoLogToConsole
		{
			get => isAutoLogToConsole;

			private set
			{
				isAutoLogToConsole = value;

				if (isAutoLogToConsole)
				{
					logModes |= LogModeInternal.Console;
				}
			}
		}

		public event EventHandler<LogEntryAddedEventArgs> LogEntryAdded;

		#endregion

		#region Init

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log
		/// </summary>
		/// <param name="regardingType">The logical name of the concerned entity.</param>
		/// <param name="regardingId">The ID of the regarding record.</param>
		/// <param name="regardingName">
		///     [OPTIONAL] The primary field value of the concerned entity (usually the 'xxx_name' field
		///     value).
		/// </param>
		public void SetRegarding(string regardingType, string regardingId, string regardingName = "")
		{
			parentLog["ldv_regardingtype"] = regardingType;
			parentLog["ldv_regardingid"] = regardingId;
			parentLog["ldv_regardingname"] = regardingName;
		}

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log
		/// </summary>
		/// <param name="regardingType">The logical name of the concerned entity.</param>
		/// <param name="regardingId">The ID of the regarding record.</param>
		/// <param name="regardingName">
		///     [OPTIONAL] The primary field value of the concerned entity (usually the 'xxx_name' field
		///     value).
		/// </param>
		public void SetRegarding(string regardingType, Guid regardingId, string regardingName = "")
		{
			SetRegarding(regardingType, regardingId.ToString(), regardingName);
		}

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log
		/// </summary>
		/// <param name="regarding">The reference to the concerned entity.</param>
		/// <param name="regardingName">
		///     [OPTIONAL] The primary field value of the concerned entity (usually the 'xxx_name' field
		///     value).
		/// </param>
		public void SetRegarding(EntityReference regarding, string regardingName = "")
		{
			regarding.Require(nameof(regarding));
			SetRegarding(regarding.LogicalName, regarding.Id, regardingName);
		}

		/// <summary>
		///     Sets the emulated 'regarding' fields in the parent log.
		/// </summary>
		/// <param name="regarding">The concerned entity.</param>
		/// <param name="primaryFieldName">
		///     [OPTIONAL=null]If null, fetch the 'name' field if it does not have a value in regarding
		///     passed.
		/// </param>
		public void SetRegarding(Entity regarding, string primaryFieldName = null)
		{
			regarding.Require(nameof(regarding));
			var nameField = string.IsNullOrWhiteSpace(primaryFieldName) && MaxLogLevel == LogLevel.Debug
				? MetadataHelpers.GetEntityAttribute<string>(OrganizationService, regarding.LogicalName,
					MetadataHelpers.EntityAttribute.PrimaryNameAttribute, configMemCacheKey)
				: primaryFieldName;
			var name = regarding.GetAttributeValue<string>(nameField)
				?? (MaxLogLevel == LogLevel.Debug
					? CrmHelpers.GetRecordName(OrganizationService, regarding.LogicalName, regarding.Id, nameField,
						configMemCacheKey)
					: string.Empty);
			SetRegarding(regarding.ToEntityReference(), name);
		}

		/// <summary>
		///     Sets the title field in the parent log.
		/// </summary>
		/// <param name="title">Title to set.</param>
		public void SetTitle(string title)
		{
			parentLog["ldv_title"] = title;
		}

		/// <summary>
		///     Sets the title field in the parent log in the format 'Log for "{name}".'.
		/// </summary>
		/// <param name="name">Name of the record.</param>
		public void SetDefaultTitle(string name)
		{
			SetTitle("Log for \"" + name + "\".");
		}

		/// <summary>
		///     Sets the title field in the parent log. Also, sets the regarding with the primary name.<br />
		///     Pass a format with '{name}' to be replaced by record name.
		/// </summary>
		/// <param name="regarding">The concerned entity.</param>
		/// <param name="primaryFieldName">
		///     [OPTIONAL=null]If null, fetch the 'name' field if it does not have a value in regarding
		///     passed.
		/// </param>
		/// <param name="titleTemplate">[OPTIONAL=null]If null, uses 'Log for "{name}".'.</param>
		public void SetTitle(Entity regarding, string primaryFieldName = null, string titleTemplate = null)
		{
			SetRegarding(regarding, primaryFieldName);

			var name = parentLog.GetAttributeValue<string>("ldv_regardingname");

			if (string.IsNullOrWhiteSpace(name))
			{
				return;
			}

			var title = (string.IsNullOrWhiteSpace(titleTemplate) ? "Log for \"{name}\"." : titleTemplate)
				.Replace("{name}", name);
			parentLog["ldv_title"] = title;
		}

		/// <summary>
		///     Sets the entry class of the parent log.
		/// </summary>
		public void SetEntryClass(string entryClass = null)
		{
			parentLog["ldv_entryclass"] = entryClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog");
		}

		/// <summary>
		///     Initializes the offline log.
		/// </summary>
		/// <param name="logPath">
		///     [OPTIONAL] The file to log to. Should be absolute path in the file system.
		///     Logs to C:\Logs\[assemblyName].csv by default.
		/// </param>
		/// <param name="isFailOver">[OPTIONAL] If 'true', only log to file if CRM is unavailable.</param>
		/// <param name="config">[OPTIONAL] Parameters to use in managing offline logging.</param>
		public void InitOfflineLog(string logPath = "", bool isFailOver = true, FileConfiguration config = null)
		{
			Config = config;
			OfflinePath = logPath;
			IsFailOver = isFailOver;
			logModes |= LogModeInternal.File;
		}

		/// <summary>
		///     Initializes console logging.
		/// </summary>
		/// <param name="isAutoLog">[OPTIONAL] If 'true', automatically output log entries to the console. Default is 'true'.</param>
		/// <param name="maxLogLevel">[OPTIONAL] The maximum log level to output to console. Default is 'Info'.</param>
		public void InitConsoleLog(bool isAutoLog = true, LogLevel maxLogLevel = LogLevel.Info)
		{
			MaxConsoleLogLevel = maxLogLevel;
			logModes |= LogModeInternal.Console;
			IsAutoLogToConsole = isAutoLog;
		}

		/// <summary>
		///     Initializes Plugin Trace service logging.
		/// </summary>
		public void InitTraceServiceLog(ITracingService traceService)
		{
			logModes |= LogModeInternal.TraceService;
			TraceService = traceService;
		}

		#endregion

		#region Function start/end logging

		/// <summary>
		///     Logs the start of execution.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionStart(string message, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			LogExecutionStart(new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the start of execution.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionStart(LogEntry logEntry = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				ExecutionStarted = true;

				var defaultMessage = "Started execution: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// log this at any level
				logEntry.Level = LogLevel.None;

				// set as root in call sequence
				execSeqStack.Push(logEntry); 

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), -1,
					true, callingFunction, callingLineNumber);

				// start measuring execution duration
				executionTimer = Stopwatch.StartNew();

				// push a zero-based timestamp
				durationsStack.Push(0);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		/// <summary>
		///     Logs the start of a function.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionStart(string message, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			LogFunctionStart(new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the start of a function.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionStart(LogEntry logEntry = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				var defaultMessage = "Started: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// set the parent as the previous in the stack, and set as parent in call sequence for next entries
				logEntry.ParentLogEntry = execSeqStack.Peek();
				execSeqStack.Push(logEntry);

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				logEntry.Level = LogLevel.Debug;

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), -1,
					true, callingFunction, callingLineNumber);

				// start measuring function duration
				functionTimersStack.Push(Stopwatch.StartNew());
				executionTimer = executionTimer ?? functionTimersStack.Peek(); // keep the first timer to log execution time
				// push a zero-based timestamp
				durationsStack.Push(0);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		/// <summary>
		///     Logs the end of a function.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionEnd(string message, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			LogFunctionEnd(new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the end of a function.
		/// </summary>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogFunctionEnd(LogEntry logEntry = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				// stop function timer and get the elapsed time
				functionTimersStack.Peek().Stop();
				var elapsedTime = (int)functionTimersStack.Pop().ElapsedMilliseconds;

				// remove the duration reference of the function
				durationsStack.Pop();

				var defaultMessage = "Finished: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// log this at any level
				logEntry.Level = LogLevel.None;

				// set parent, then remove it from sequence of calls
				execSeqStack.Pop();

				if (execSeqStack.Any())
				{
					logEntry.ParentLogEntry = execSeqStack.Peek();
				}

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				logEntry.Level = LogLevel.Debug;

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), elapsedTime,
					true, callingFunction, callingLineNumber);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="autoFlush">[Optional] Automatically flush after ending execution</param>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionEnd(string message, bool autoFlush = true, ExecutionEndState state = ExecutionEndState.Success,
			IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			LogExecutionEnd(autoFlush, state, new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		/// <param name="message">[Optional] The message to set in the log entry</param>
		/// <param name="autoFlush">[Optional] Automatically flush after ending exectution</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionEnd(ExecutionEndState state, string message = "", bool autoFlush = true,
			IExecutionContext context = null, string callingClass = null, string stackTrace = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			LogExecutionEnd(autoFlush, state, new LogEntry(message), context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the end of execution.
		/// </summary>
		/// <param name="autoFlush">[Optional] Automatically flush after ending exectution</param>
		/// <param name="state">[Optional] The state at which the execution ended</param>
		/// <param name="logEntry">[Optional] The log entry object that includes all relevant information</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogExecutionEnd(bool autoFlush = true, ExecutionEndState state = ExecutionEndState.Success,
			LogEntry logEntry = null,
			IExecutionContext context = null, string callingClass = null, string stackTrace = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				// stop execution timer
				executionTimer.Stop();

				// remove the duration reference of the function
				durationsStack.Pop();

				AssemblyExecutionState = (AssemblyExecutionState == ExecutionEndState.Failure) ? AssemblyExecutionState : state;

				var defaultMessage = "Finished execution: " + callingFunction;

				logEntry = logEntry ?? new LogEntry(defaultMessage);

				// log this at any level
				logEntry.Level = LogLevel.None;

				// set parent, then remove it from sequence of calls
				if (execSeqStack.Any())
				{
					logEntry.ParentLogEntry = execSeqStack.Pop();
				}

				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					logEntry.Message = defaultMessage;
				}

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
					(int)executionTimer.ElapsedMilliseconds, true, callingFunction, callingLineNumber);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
			finally
			{
				if (autoFlush)
				{
					Flush();
				}
			}
		}

		#endregion

		#region Logging Helpers

		public void LogError(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message, LogLevel.Error, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Error, string.Empty, string.Empty, information),
					callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
		}

		public void LogError(Exception exception, IExecutionContext context = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (context == null)
			{
				Log(exception, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
			else
			{
				Log(exception, context, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
		}

		public void LogWarning(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message, LogLevel.Warning, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Warning, string.Empty, string.Empty, information),
					callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
		}

		public void LogInfo(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Info, string.Empty, string.Empty, information),
					callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
		}

		public void LogDebug(string message, string information = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (string.IsNullOrWhiteSpace(information))
			{
				Log(message, LogLevel.Debug, callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
			else
			{
				Log(new LogEntry(message, LogLevel.Debug, string.Empty, string.Empty, information),
					callingFunction: callingFunction, callingLineNumber: callingLineNumber);
			}
		}

		#endregion

		#region Logging

		/// <summary>
		///     Logs an entry.
		/// </summary>
		/// <param name="message">The message to set in the log entry</param>
		/// <param name="level">[Optional] The logging level, above which, this entry will be skipped</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void Log(string message, LogLevel level = LogLevel.Info, string regardingType = "",
			string regardingName = "", IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			Log(new LogEntry(message, level), regardingType, regardingName, context,
				callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), null, false,
				callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs an exception.
		/// </summary>
		/// <param name="exception">The exception that was thrown</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void Log(Exception exception, IExecutionContext context, string regardingType = "",
			string regardingName = "", string callingClass = null, string stackTrace = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			Log(new LogEntry(exception, exception.Message), regardingType, regardingName, context,
				callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace ?? exception.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), null, false,
				callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs an exception.
		/// </summary>
		/// <param name="exception">The exception that was thrown</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="information">
		///     [Optional] Extra information to add to the log entry (in this case, it should be the context
		///     parse)
		/// </param>
		public void Log(Exception exception, string regardingType = "", string regardingName = "", string information = "",
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			Log(new LogEntry(exception, exception.Message, information: information), regardingType, regardingName,
				callingClass: callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
				stackTrace: stackTrace ?? exception.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
				callingFunction: callingFunction, callingLineNumber: callingLineNumber);
		}

		/// <summary>
		///     Logs an entry.
		/// </summary>
		/// <param name="logEntry">The log entry object that includes all relevant information</param>
		/// <param name="regardingType">[Optional] The logical name of the entity concerned with this log entry as a string</param>
		/// <param name="regardingName">[Optional] The name of the record concerned with this log entry as a string</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void Log(LogEntry logEntry, string regardingType = "", string regardingName = "",
			IExecutionContext context = null, string callingClass = null, string stackTrace = null, int? elapsedTime = null,
			bool parent = false, [CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				// set parent of this entry to top of the stack entry
				if (!parent)
				{
					logEntry.Require(nameof(logEntry));
					logEntry.ParentLogEntry = execSeqStack.Peek();
				}

				// calculate the duration between the last log entry in this function and this one
				if (elapsedTime == null)
				{
					// get the last recorded duration since function start
					var lastDuration = durationsStack.Pop();

					// get the function timer
					var functionDuration
						= (int)(functionTimersStack.Any()
							? functionTimersStack.Peek().ElapsedMilliseconds
							: executionTimer.ElapsedMilliseconds);

					// add a snapshot
					durationsStack.Push(functionDuration);

					// calculate the time it took to get from the last recorded entry to this entry
					logEntry.ElapsedTime = functionDuration - lastDuration;
				}
				else
				{
					logEntry.ElapsedTime = elapsedTime.Value;
				}

				logEntry.StartDate = DateTime.UtcNow.AddMilliseconds(-logEntry.ElapsedTime);

				logEntry.RegardingType = regardingType ?? logEntry.RegardingType;
				logEntry.RegardingName = regardingName ?? logEntry.RegardingName;

				// exception flag
				if (logEntry.Exception != null)
				{
					exceptionThrown = true;
					logEntry.ExceptionThrown = true;
				}

				if (logEntry.ExceptionThrown)
				{
					var logEntryTemp = logEntry;

					while ((logEntryTemp = logEntryTemp.ParentLogEntry) != null)
					{
						logEntryTemp.ExceptionThrown = true;
					}
				}

				// plugin context
				if (context != null && OrganizationService != null)
				{
					var pluginInfo = PluginInfo.GetPluginExecutionInfo(OrganizationService, context);

					if ((logModes & ~LogModeInternal.TraceService) == 0)
					{
						logQueue.Peek().Information = pluginInfo;
					}
					else
					{
						logEntry.Information = pluginInfo;
					}
				}

				// increment the log entries index
				logEntry.CurrentEntryIndex = CurrentEntryIndex++;

				// code info
				logEntry.StackTrace = stackTrace ?? logEntry.StackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog");
				logEntry.CallingClass = callingClass ?? logEntry.CallingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog");
				logEntry.CallingFunction = callingFunction ?? logEntry.CallingFunction;
				logEntry.CallingLineNumber = callingLineNumber;

				logQueue.Enqueue(logEntry);
				OnLogEntryAdded(new LogEntryAddedEventArgs { LogEntry = logEntry });

				// keep the first entry with an exception to show in root
				exceptionLogEntry = logEntry.ExceptionThrown ? logEntry : exceptionLogEntry;

				if (IsAutoLogToConsole)
				{
					LogToConsole(logEntry);
				}
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		private void OnLogEntryAdded(LogEntryAddedEventArgs e)
		{
			LogEntryAdded?.Invoke(this, e);
		}

		public void LogKeyValues(string title, string[] paramNames, object[] paramValues,
			LogLevel level = LogLevel.Info, string regardingType = "",
			string regardingName = "", IExecutionContext context = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			try
			{
				paramNames.Require(nameof(paramNames));
				paramValues.Require(nameof(paramValues));

				var paramInfoBuilder = new StringBuilder();

				for (var i = 0; i < paramNames.Length; i++)
				{
					if (i != 0)
					{
						paramInfoBuilder.Append("\r\n");
					}

					paramInfoBuilder
						.Append(paramNames[i])
						.Append(" = ")
						.Append(Helpers.GetStringRepresentation(paramValues[i]));
				}

				Log(new LogEntry(title, level, null, null, paramInfoBuilder.ToString()),
					regardingType, regardingName, context,
					Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"), Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
					null, false, callingFunction, callingLineNumber);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		public void LogKeyValues(string title, IDictionary<string, object> parameters,
			LogLevel level = LogLevel.Info, string regardingType = "",
			string regardingName = "", IExecutionContext context = null,
			[CallerMemberName] string callingFunction = "", [CallerLineNumber] int callingLineNumber = 0)
		{
			parameters.Require(nameof(parameters));
			LogKeyValues(title, parameters.Keys.ToArray(), parameters.Values.ToArray(),
				level, regardingType, regardingName, context, callingFunction, callingLineNumber);
		}

		/// <summary>
		///     Logs the current execution line in the code.
		/// </summary>
		/// <param name="message">[OPTIONAL] The message to set in the log entry</param>
		/// <param name="context">
		///     [Optional] The plugin context to parse. If given, the logger will go over all the parameters and
		///     fetch info from CRM
		/// </param>
		public void LogLine(string message = null, IExecutionContext context = null,
			string callingClass = null, string stackTrace = null, [CallerMemberName] string callingFunction = "",
			[CallerLineNumber] int callingLineNumber = 0)
		{
			if (MaxLogLevel == LogLevel.None)
			{
				return;
			}

			try
			{
				if (!ExecutionStarted)
				{
					LogExecutionStart(callingClass: callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
						stackTrace: stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"),
						callingFunction: callingFunction, callingLineNumber: callingLineNumber);
				}

				var defaultMessage = "Execution reached line " + callingLineNumber;

				var logEntry = new LogEntry(message ?? defaultMessage) { Level = LogLevel.Debug };

				Log(logEntry, string.Empty, string.Empty, context, callingClass ?? Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					stackTrace ?? Helpers.GetStackTrace(-1, "Yagasoft.Libraries.Common.CrmLog"), -1,
					false, callingFunction, callingLineNumber);
			}
			catch
			{
				if (context != null && OrganizationService != null)
				{
					throw;
				}
			}
		}

		/// <summary>
		///     Formats the message with colouring and timestamp, and outputs to console if available.
		/// </summary>
		/// <param name="message">The message to output to console.</param>
		/// <param name="logLevel">Log level to use for formatting. Default is 'Info'.</param>
		public void LogToConsole(string message, LogLevel logLevel = LogLevel.Info)
		{
			LogToConsole(new LogEntry(message, logLevel));
		}

		/// <summary>
		///     Formats the log entry with colouring and timestamp, and outputs to console if available.
		/// </summary>
		/// <param name="logEntry">The log entry object that includes all relevant information.</param>
		public void LogToConsole(LogEntry logEntry)
		{
			logEntry.Require(nameof(logEntry));

			try
			{
				if (!logModes.HasFlag(LogModeInternal.Console) || logEntry.Level > MaxConsoleLogLevel)
				{
					return;
				}

				if (logEntry.ExceptionThrown)
				{
					Console.ForegroundColor = ConsoleColor.Red;
					Console.WriteLine("============================ !! EXCEPTION !! ===============================");
					Console.ResetColor();
					Console.WriteLine(GetFormattedEntry(logEntry));
					Console.ForegroundColor = ConsoleColor.Red;
					Console.WriteLine("============================================================================");
					Console.ResetColor();
				}
				else
				{
					Console.ForegroundColor = ConsoleColor.DarkGreen;
					Console.Write("{0:ddd hh:mm:ss tt: }", DateTime.Now);

					switch (logEntry.Level)
					{
						case LogLevel.Error:
							Console.BackgroundColor = ConsoleColor.White;
							Console.ForegroundColor = ConsoleColor.Red;
							break;
						case LogLevel.Warning:
							Console.ForegroundColor = ConsoleColor.Yellow;
							break;
						case LogLevel.Debug:
							Console.ForegroundColor = ConsoleColor.DarkCyan;
							break;
						default:
							Console.ResetColor();
							break;
					}

					Console.WriteLine(logEntry.Message);
					Console.ResetColor();
				}
			}
			catch (Exception)
			{
				// ignored
			}
		}

		/// <summary>
		///     Sets the state at which the execution ended
		/// </summary>
		/// <param name="state">The state at which the execution ended</param>
		public void SetExecutionState(ExecutionEndState state)
		{
			AssemblyExecutionState = state;
		}

		/// <summary>
		///     Sets the state at which the execution ended as a failure
		/// </summary>
		public void ExecutionFailed()
		{
			AssemblyExecutionState = ExecutionEndState.Failure;
		}

		/// <summary>
		///     Created the parent log, and creates each log entry in the queue.
		/// </summary>
		/// <param name="inBulk">If true, created all log entries using ExecuteMultiple</param>
		public void Flush(bool inBulk = true)
		{
			var lockObject = this;

			Action action =
				() =>
				{
					lock (lockObject)
					{
						if (MaxLogLevel == LogLevel.None
							|| logQueue.All(entry => entry.Level == LogLevel.None)
							|| (logQueue.All(entry => entry.Level == LogLevel.None || entry.Level > MaxLogLevel)
								&& AssemblyExecutionState != ExecutionEndState.Failure))
						{
							return;
						}

						RunFlushAction(inBulk);
					}
				};

			if (isPlugin || logModes.HasFlag(LogModeInternal.File))
			{
				action.Invoke();
			}
			else
			{
				Task.Run(() => action());
			}
		}

		#endregion

		private static string EscapeCsv(string input)
		{
			if (string.IsNullOrWhiteSpace(input))
			{
				return input;
			}
			
			return "\"" + input.Replace("\"", "\"\"") + "\"";
		}

		private static string BuildLogId(LogEntry logEntry)
		{
			return $"LogEntry-{logEntry.StartDate?.ToLocalTime() ?? DateTime.Now:yyyy_MM_dd-HH_mm_ss_fff}";
		}

		#region Flush

		private void RunFlushAction(bool inBulk)
		{
			try
			{
				var isCrmLog = logModes.HasFlag(LogModeInternal.CrmLog);

				parentLog["ldv_executionendstate"] = new OptionSetValue((int)AssemblyExecutionState);
				parentLog["ldv_executionduration"] = (int)executionTimer.ElapsedMilliseconds;
				parentLog["ldv_exceptionthrown"] = exceptionThrown;

				if (logModes.HasFlag(LogModeInternal.File))
				{
					offlineQueue = new Queue<LogEntry>(logQueue);
				}

				if ((logModes & ~LogModeInternal.File) == 0 || isBulkPreviously == true)
				{
					logQueue.Clear();
					return;
				}

				var requests = new List<OrganizationRequest>();
				var serialisedLogEntries = new StringBuilder();

				inBulk = isBulkPreviously == null && inBulk;

				if (isCrmLog && !inBulk && !isParentCreated)
				{
					OrganizationService.Create(parentLog);
				}

				var traceServiceBuffer = new StringBuilder();

				while (logQueue.Count > 0)
				{
					var logEntry = logQueue.Dequeue();

					// if the log entry's level is above the maximum, then no need to log it
					// unless the execution failed
					if (logEntry.Level > MaxLogLevel
						&& AssemblyExecutionState != ExecutionEndState.Failure)
					{
						continue;
					}
					
					if (logModes.HasFlag(LogModeInternal.TraceService)
						&& !new [] {"Started: ", "Finished: "}.Any(e => logEntry.Message.StartsWith(e)))
					{
						traceServiceBuffer.Append($"\r\n{GetTraceServiceFormattedEntry(logEntry)}");
					}

					var target = CreateEntryEntity(logEntry);

					if (isCrmLog)
					{
						if (inBulk)
						{
							serialisedLogEntries.Append("<|||>")
								.Append(EntitySerializer.SerializeObject(target));
						}
						else
						{
							OrganizationService.Create(target);
						}
					}
				}

				if (traceServiceBuffer.Length > 0)
				{
					TraceService.Trace(traceServiceBuffer.ToString());
				}

				if (isCrmLog)
				{
					if (exceptionLogEntry != null)
					{
						var updatedParent =
							new Entity("ldv_log")
							{
								Id = parentLog.Id,
								["ldv_exceptionlogentry"] =
									new EntityReference("ldv_logentry", exceptionLogEntry.LogEntryId),
								["ldv_exceptionmessage"] = exceptionLogEntry.Message
							};

						if (inBulk)
						{
							serialisedLogEntries.Append("<|||><PARENT>")
								.Append(EntitySerializer.SerializeObject(updatedParent));
						}
						else
						{
							OrganizationService.Update(updatedParent);
						}
					}

					if (inBulk)
					{
						parentLog["ldv_serialisedlogentries"] = serialisedLogEntries.ToString().Compress();
						requests.Add(new CreateRequest { Target = parentLog });
						CrmHelpers.ExecuteBulk(OrganizationService, requests);
					}
				}

				isParentCreated = true;
				isBulkPreviously = inBulk;
			}
			catch
			{
				try
				{
					if (IsFailOver)
					{
						FlushOffline();
					}
				}
				catch
				{
				}

				throw;
			}
			finally
			{
				if (!IsFailOver)
				{
					FlushOffline();
				}
			}
		}

		/// <summary>
		///     Flushes to local file.
		/// </summary>
		private void FlushOffline()
		{
			try
			{
				if (!logModes.HasFlag(LogModeInternal.File))
				{
					return;
				}

				PrepareLogPath();

				if (IsCreateFile())
				{
					CreateLogFile();
				}

				// open the log file and write the log entries
				using (var file = File.Open(OfflinePath, FileMode.Append, FileAccess.Write, FileShare.ReadWrite))
				using (var stream = new StreamWriter(file))
				{
					while (offlineQueue.Any())
					{
						var logEntry = offlineQueue.Dequeue();

						if (logEntry.Level > MaxLogLevel
							&& AssemblyExecutionState != ExecutionEndState.Failure)
						{
							continue;
						}
						
						stream.Write(GetFormattedCsvEntry(logEntry));
					}

					stream.Flush();
				}
			}
			catch
			{
				// ignored
			}
		}

		private bool IsCreateFile()
		{
			// if the file or config do not exist, create file
			if (!File.Exists(OfflinePath) || Config == null)
			{
				return true;
			}

			// check size and date limit for split
			var dateFile = Path.Combine(Path.GetDirectoryName(OfflinePath) ?? "",
				Path.GetFileNameWithoutExtension(OfflinePath) + ".dat");
			var dateText = File.Exists(dateFile)
				? File.ReadAllText(dateFile)
				: DateTime.UtcNow.ToString("yyyy-MM-dd_HH-mm-ss-fff");

			if (!File.Exists(dateFile))
			{
				File.WriteAllText(dateFile, DateTime.UtcNow.ToString("yyyy-MM-dd_HH-mm-ss-fff"));
			}

			var fileDate = DateTime.ParseExact(dateText, "yyyy-MM-dd_HH-mm-ss-fff", CultureInfo.InvariantCulture,
				DateTimeStyles.AssumeUniversal);

			var newFileDate = string.Format("{0:" + (Config.FileDateFormat ?? "yyyy-MM-dd_HH-mm-ss-fff") + "}",
				fileDate.ToLocalTime());
			var datedName = Path.Combine(Path.GetDirectoryName(OfflinePath) ?? "",
				$"{Path.GetFileNameWithoutExtension(OfflinePath)}_{newFileDate}{Path.GetExtension(OfflinePath)}");

			// option exists for size limit
			if ((Config.FileSplitMode == SplitMode.Size || Config.FileSplitMode == SplitMode.Both)
				&& Config.MaxFileSizeKb > 0 && new FileInfo(OfflinePath).Length / 1024 > Config.MaxFileSizeKb)
			{
				File.Move(OfflinePath, datedName);
				return true;
			}

			// option exists for date limit
			if ((Config.FileSplitMode == SplitMode.Date || Config.FileSplitMode == SplitMode.Both)
				&& Config.FileSplitFrequency != null)
			{
				var splitDate = Config.FileSplitDate;

				// calculate the target split date for the file based on its creation date
				switch (Config.FileSplitFrequency)
				{
					case SplitFrequency.Hourly:
						splitDate = new DateTime(fileDate.Year, fileDate.Month, fileDate.Day,
							fileDate.Hour, splitDate.Minute, splitDate.Second).AddHours(1);
						break;

					case SplitFrequency.Daily:
						splitDate = new DateTime(fileDate.Year, fileDate.Month, fileDate.Day,
							splitDate.Hour, splitDate.Minute, splitDate.Second).AddDays(1);
						break;

					case SplitFrequency.Monthly:
						splitDate = new DateTime(fileDate.Year, fileDate.Month, splitDate.Day,
							splitDate.Hour, splitDate.Minute, splitDate.Second).AddMonths(1);
						break;

					case SplitFrequency.Yearly:
						splitDate = new DateTime(fileDate.Year, splitDate.Month, splitDate.Day,
							splitDate.Hour, splitDate.Minute, splitDate.Second).AddYears(1);
						break;
				}

				// rename
				if (DateTime.UtcNow > splitDate)
				{
					File.Move(OfflinePath, datedName);
					return true;
				}
			}

			return false;
		}

		private void PrepareLogPath()
		{
			// no file name specified, create default name
			if (string.IsNullOrWhiteSpace(OfflinePath))
			{
				OfflinePath = $"C:\\Logs\\{Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common")}.csv";
			}

			// if directory was given, add filename to it
			if (!Path.HasExtension(OfflinePath))
			{
				OfflinePath = Path.Combine(OfflinePath, Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common") + ".csv");
			}

			var folder = Path.GetDirectoryName(OfflinePath);

			// if categorisation is needed, add the assembly folder
			if (Config != null && Config.CategoriseByType == true)
			{
				OfflinePath = Path.Combine(Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), Path.GetFileName(OfflinePath));

				if (!string.IsNullOrWhiteSpace(folder))
				{
					OfflinePath = Path.Combine(folder, OfflinePath);
				}
			}

			folder = Path.GetDirectoryName(OfflinePath);

			// create path if it doesn't exist
			if (!string.IsNullOrWhiteSpace(folder))
			{
				Directory.CreateDirectory(folder);
			}
		}

		/// <summary>
		///     Creates an entity containing the log entry data
		/// </summary>
		/// <param name="logEntry">The log entry.</param>
		/// <returns>The CRM entity object including all info in the log entry object</returns>
		private Entity CreateEntryEntity(LogEntry logEntry)
		{
			var target =
				new Entity("ldv_logentry")
				{
					Id = logEntry.LogEntryId,
					["ldv_name"] = BuildLogId(logEntry),
					["ldv_message"] = logEntry.Message,
					["ldv_entryindex"] = logEntry.CurrentEntryIndex,
					["ldv_startdate"] = logEntry.StartDate,
					["ldv_regardingtype"] = logEntry.RegardingType,
					["ldv_regardingname"] = logEntry.RegardingName,
					["ldv_stacktrace"] = logEntry.StackTrace
				};

			if (logEntry.Exception != null)
			{
				if (string.IsNullOrWhiteSpace(logEntry.Message))
				{
					target["ldv_message"] = logEntry.Message = "Exception: " + logEntry.Exception.Message;
				}

				target["ldv_exception"] = logEntry.Exception.GetType().Name;
				target["ldv_exceptionsource"] = logEntry.Exception.Source;
				target["ldv_stacktrace"] = logEntry.Exception.StackTrace;

				if (logEntry.Exception.InnerException != null)
				{
					target["ldv_innerexception"] = logEntry.Exception.InnerException.GetType().Name;
					target["ldv_innerexceptionmessage"] = logEntry.Exception.InnerException.Message;
					target["ldv_innerexceptionsource"] = logEntry.Exception.InnerException.Source;
					target["ldv_innerexceptionstacktrace"] = logEntry.Exception.InnerException.StackTrace;
				}
			}

			target["ldv_exceptionthrown"] = logEntry.ExceptionThrown;

			target["ldv_level"] = new OptionSetValue((int)logEntry.Level);

			if (logEntry.UserId != Guid.Empty)
			{
				target["ldv_user"] = new EntityReference("systemuser", logEntry.UserId);
			}
			else if (UserId != Guid.Empty)
			{
				target["ldv_user"] = new EntityReference("systemuser", UserId);
			}

			target["ldv_assembly"] = logEntry.Assembly ?? Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common");
			target["ldv_class"] = logEntry.CallingClass;
			target["ldv_callingfunction"] = logEntry.CallingFunction;
			target["ldv_linenumber"] = logEntry.CallingLineNumber;

			if (logEntry.ElapsedTime > -1)
			{
				target["ldv_executionduration"] = logEntry.ElapsedTime;
			}

			target["ldv_information"] = logEntry.Information;

			target["ldv_parentlogid"] = parentLog.ToEntityReference();

			if (logEntry.ParentLogEntry != null)
			{
				target["ldv_parentlogentryid"] = new EntityReference("ldv_logentry", logEntry.ParentLogEntry.LogEntryId);
			}

			return target;
		}

		private void CreateLogFile()
		{
			File.Create(OfflinePath).Close();

			var data = Encoding.UTF8.GetBytes("Log ID,Assembly,Entry Class,Entry Function,Date,Index," +
				"Log Level,Duration (ms),Class,Function,Line Number,Message,Exception Thrown," +
				"Exception,Source,Stack Trace,Inner Exception,Inner Source,Information," +
				"Log Start Date,Execution State,Execution Duration," +
				"Regarding Type,Regarding Name,Regarding ID,User ID\r\n");
			var bytes = Encoding.UTF8.GetPreamble().Concat(data).ToArray();
			File.WriteAllBytes(OfflinePath, bytes);

			var dateFile = Path.Combine(Path.GetDirectoryName(OfflinePath) ?? "",
				Path.GetFileNameWithoutExtension(OfflinePath) + ".dat");
			File.WriteAllText(dateFile, DateTime.UtcNow.ToString("yyyy-MM-dd_HH-mm-ss-fff"));
		}

		private string GetFormattedEntry(LogEntry logEntry, bool isExcludeTrace = false)
		{
			try
			{
				var stringBuilder = new StringBuilder();

				stringBuilder.AppendFormat("\r\nStart date: {0}", logEntry.StartDate.GetValueOrDefault().ToLocalTime());
				stringBuilder.AppendFormat("\r\nLog level: {0}", logEntry.Level);
				stringBuilder.AppendFormat("\r\nDuration: {0} ms", logEntry.ElapsedTime);
				stringBuilder.AppendFormat("\r\nAssembly: {0}",
					logEntry.Assembly ?? Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"));
				stringBuilder.AppendFormat("\r\nClass: {0}", logEntry.CallingClass);
				stringBuilder.AppendFormat("\r\nCalling function: {0}", logEntry.CallingFunction);
				stringBuilder.AppendFormat("\r\nLine number: {0}", logEntry.CallingLineNumber);

				if (logEntry.Exception == null)
				{
					stringBuilder.AppendFormat("\r\nMessage: {0}", logEntry.Message);

					if (!isExcludeTrace)
					{
						stringBuilder.AppendFormat("\r\nStack trace: {0}", logEntry.StackTrace);
					}
				}
				else
				{
					stringBuilder.Append($"\r\n--- START ** EXCEPTION ---"
						+ $"\r\n{logEntry.Exception.BuildExceptionMessage()}"
						+ $"\r\n--- EXCEPTION ** END ---");
				}

				if (logEntry.Information.IsFilled())
				{
					stringBuilder.AppendFormat("\r\nInformation:\r\n{0}", logEntry.Information);
				}

				return stringBuilder.ToString();
			}
			catch (Exception e)
			{
				return $"Logger error:\r\n{e}";
			}
		}

		private string GetTraceServiceFormattedEntry(LogEntry logEntry)
		{
			try
			{
				var stringBuilder = new StringBuilder();

				if (logEntry.Message.StartsWith("Started execution: "))
				{
					stringBuilder.Append($"{logEntry.StartDate.GetValueOrDefault().ToLocalTime()}: ");
				}

				////stringBuilder.Append($"Start date: {logEntry.StartDate.GetValueOrDefault().ToLocalTime()}");
				////stringBuilder.AppendFormat("\r\nLog level: {0}", logEntry.Level);
				////stringBuilder.AppendFormat("\r\nDuration: {0} ms", logEntry.ElapsedTime);
				////stringBuilder.AppendFormat("\r\nClass: {0}", logEntry.CallingClass.Split('.').LastOrDefault());
				////stringBuilder.AppendFormat("\r\nMethod: {0}", logEntry.CallingFunction);
				////stringBuilder.AppendFormat("\r\nLine: {0}", logEntry.CallingLineNumber);

				if (logEntry.Exception == null)
				{
					if (logEntry.Level != LogLevel.Info)
					{
						stringBuilder.Append($"[{logEntry.Level}] ");
					}

					stringBuilder.Append($"{logEntry.Message}"
						+ $" | {logEntry.ElapsedTime} ms"
						+ $" | {logEntry.CallingClass?.Split('.').LastOrDefault()}"
						+ $".{logEntry.CallingFunction} at {logEntry.CallingLineNumber}");
				}
				else
				{
					stringBuilder.Append($"\r\n-- START ** EXCEPTION -"
						+ $"\r\n{logEntry.Exception.BuildExceptionMessage()}"
						+ $"\r\n-- END ** EXCEPTION -");
				}

				if (logEntry.Message.StartsWith("Started execution: ") && logEntry.Information.IsFilled())
				{
					stringBuilder.Append($"\r\nInformation:\r\n{logEntry.Information}");
				}

				return stringBuilder.ToString();
			}
			catch (Exception e)
			{
				return $"Logger error:\r\n{e}";
			}
		}

		private string GetFormattedCsvEntry(LogEntry logEntry)
		{
			var stringBuilder = new StringBuilder();

			stringBuilder.AppendFormat("{0}", parentLog.GetAttributeValue<string>("ldv_name"));
			stringBuilder.AppendFormat(",{0}",
				EscapeCsv(logEntry.Assembly ?? Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common")));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(parentLog.GetAttributeValue<string>("ldv_entryclass")));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(parentLog.GetAttributeValue<string>("ldv_entryfunction")));
			stringBuilder.AppendFormat(",{0}", logEntry.StartDate.GetValueOrDefault().ToLocalTime());
			stringBuilder.AppendFormat(",{0}", logEntry.CurrentEntryIndex);
			stringBuilder.AppendFormat(",{0}", logEntry.Level);
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.ElapsedTime.ToString()));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.CallingClass));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.CallingFunction));
			stringBuilder.AppendFormat(",{0}", logEntry.CallingLineNumber);

			if (logEntry.Exception != null)
			{
				stringBuilder.AppendFormat(",{0}",
					string.IsNullOrWhiteSpace(logEntry.Message)
						? EscapeCsv(logEntry.Exception.Message)
						: EscapeCsv(logEntry.Message));

				stringBuilder.AppendFormat(",{0}", logEntry.ExceptionThrown);
				stringBuilder.AppendFormat(",{0},{1},{2}",
					EscapeCsv(logEntry.Exception.GetType().Name),
					EscapeCsv(logEntry.Exception.Source), EscapeCsv(logEntry.Exception.StackTrace));

				if (logEntry.Exception.InnerException != null)
				{
					stringBuilder.AppendFormat(",{0},{1}",
						EscapeCsv(logEntry.Exception.InnerException.GetType().Name),
						EscapeCsv(logEntry.Exception.InnerException.Message));
				}
				else
				{
					stringBuilder.Append(",,");
				}
			}
			else
			{
				stringBuilder.AppendFormat(",{0},{1},,,,,", EscapeCsv(logEntry.Message), logEntry.ExceptionThrown);
			}

			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.Information));

			stringBuilder.AppendFormat(",{0}", LogStartDate);
			stringBuilder.AppendFormat(",{0}", AssemblyExecutionState);
			stringBuilder.AppendFormat(",{0}", parentLog.GetAttributeValue<int>("ldv_executionduration"));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.RegardingType));
			stringBuilder.AppendFormat(",{0}", EscapeCsv(logEntry.RegardingName));
			stringBuilder.AppendFormat(",{0}", parentLog.GetAttributeValue<string>("ldv_regardingid"));
			stringBuilder.AppendFormat(",{0}\r\n", logEntry.UserId == Guid.Empty ? UserId : logEntry.UserId);

			return stringBuilder.ToString();
		}

		#endregion

		#region Init

		private PrivateConfiguration GetConfiguration()
		{
			if (OrganizationService == null)
			{
				return null;
			}

			var config = CrmHelpers.GetGenericConfig(OrganizationService, orgId);

			return config == null
				? null
				: new PrivateConfiguration
				  {
					  LogLevel = (LogLevel)(config.GetAttributeValue<OptionSetValue>("ldv_loglevel")
						  ?? new OptionSetValue((int)LogLevel.Warning)).Value,
					  LogMode = (LogMode)(config.GetAttributeValue<OptionSetValue>("ldv_logmode")
						  ?? new OptionSetValue((int)LogMode.Crm)).Value,
					  LogPath = config.GetAttributeValue<string>("ldv_logpath"),
					  MaxFileSizeKb = config.GetAttributeValue<int?>("ldv_maxfilesize"),
					  FileDateFormat = config.GetAttributeValue<string>("ldv_logfiledateformat"),
					  FileSplitMode = config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitmode") == null
						  ? null
						  : (SplitMode?)config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitmode").Value,
					  FileSplitFrequency = config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitfrequency") == null
						  ? null
						  : (SplitFrequency?)config.GetAttributeValue<OptionSetValue>("ldv_logfilesplitfrequency").Value,
					  FileSplitDate = config.GetAttributeValue<DateTime>("ldv_logfilesplitdate"),
					  CategoriseByType = config.GetAttributeValue<bool?>("ldv_iscategorisebytype"),
					  AssemblyFilter = config.GetAttributeValue<string>("ldv_assemblyfilter"),
					  AssemblyExclusion = config.GetAttributeValue<string>("ldv_assemblyexclusion")
				  };
		}

		/// <summary>
		///     Initialises the CRM logger.
		/// </summary>
		/// <param name="organizationService">The service to be used to flush the entries to CRM</param>
		/// <param name="traceService">The Plugin Trace service to log entries to CRM</param>
		/// <param name="maximumLevel">[OPTIONAL] The maximum logging level to use, above which, no logs will be saved</param>
		private void InitialiseLog(IOrganizationService organizationService, ITracingService traceService = null,
			LogLevel? maximumLevel = null, [CallerMemberName] string callingFunction = "")
		{
			logQueue = new Queue<LogEntry>();
			offlineQueue = new Queue<LogEntry>();
			execSeqStack = new Stack<LogEntry>();

			functionTimersStack = new Stack<Stopwatch>();
			durationsStack = new Stack<int>();

			OrganizationService = organizationService;

			if (traceService != null)
			{
				InitTraceServiceLog(traceService);
			}

			LogStartDate = DateTime.UtcNow;
			CurrentEntryIndex = 1;

			PrivateConfiguration config = null;

			if (logModes.HasFlag(LogModeInternal.CrmLog) || logModes.HasFlag(LogModeInternal.TraceService))
			{
				config = GetConfiguration();
			}

			MaxLogLevel = maximumLevel ?? config?.LogLevel ?? LogLevel.Warning;

			// if assembly is excluded, then turn off logging
			if (!string.IsNullOrWhiteSpace(config?.AssemblyFilter))
			{
				var isAssemblyIncluded =
					Regex.IsMatch(Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), config.AssemblyFilter);
				MaxLogLevel = isAssemblyIncluded ? MaxLogLevel : LogLevel.None;
			}

			if (!string.IsNullOrWhiteSpace(config?.AssemblyExclusion))
			{
				var isAssemblyExcluded =
					Regex.IsMatch(Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"), config.AssemblyExclusion);
				MaxLogLevel = isAssemblyExcluded ? LogLevel.None : MaxLogLevel;
			}

			if (isSandboxMode && logModes.HasFlag(LogModeInternal.File))
			{
				logModes &= ~LogModeInternal.File;
			}

			if (logModes.HasFlag(LogModeInternal.File))
			{
				InitOfflineLog(config == null ? string.Empty : config.LogPath, false, config);
			}

			if (UserId == Guid.Empty && OrganizationService != null && MaxLogLevel != LogLevel.None)
			{
				UserId = ((WhoAmIResponse)OrganizationService.Execute(new WhoAmIRequest())).UserId;
			}

			InitLogEntity(callingFunction);
		}

		/// <summary>
		///     Initializes the parent log entity.
		/// </summary>
		private void InitLogEntity([CallerMemberName] string callingFunction = "")
		{
			parentLog =
				new Entity("ldv_log")
				{
					Id = Guid.NewGuid(),
					["ldv_name"] = $"Log-{LogStartDate.ToLocalTime():yyyy_MM_dd-HH_mm_ss_fff}",
					["ldv_assembly"] = Helpers.GetAssemblyName(-1, "Yagasoft.Libraries.Common"),
					["ldv_entryclass"] = Helpers.GetClassName(-1, "Yagasoft.Libraries.Common.CrmLog"),
					["ldv_entryfunction"] = callingFunction,
					["ldv_startdate"] = LogStartDate,
					["ldv_user"] = new EntityReference("systemuser", UserId),
					["ldv_executionendstate"] = new OptionSetValue((int)ExecutionEndState.Success)
				};
		}

		#endregion

		#region Inner classes

		private class PrivateConfiguration : FileConfiguration
		{
			internal LogLevel LogLevel
			{
				get; set;
			}

			internal LogMode LogMode
			{
				get; set;
			}

			internal string LogPath
			{
				get; set;
			}

			internal string AssemblyFilter
			{
				get; set;
			}

			internal string AssemblyExclusion
			{
				get; set;
			}
		}

		#endregion
	}

	public class LogEntryAddedEventArgs : EventArgs
	{
		public LogEntry LogEntry
		{
			get; set;
		}
	}

	public class FileConfiguration
	{
		public int? MaxFileSizeKb
		{
			get; set;
		}

		public string FileDateFormat
		{
			get; set;
		}

		public SplitMode? FileSplitMode
		{
			get; set;
		}

		public SplitFrequency? FileSplitFrequency
		{
			get; set;
		}

		public DateTime FileSplitDate
		{
			get; set;
		}

		public bool? CategoriseByType
		{
			get; set;
		}
	}

	/// <summary>
	///     Contains information related to the log entry.<br />
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public class LogEntry
	{
		private int elapsedTime;
		private int currentEntryIndex;

		#region Constructors

		public LogEntry(string message, LogLevel level = LogLevel.Info, string regardingType = "", string regardingName = "",
			string information = "") : this(message, null, level, regardingType, regardingName, information)
		{
		}

		public LogEntry(Exception exception, string message = "", string regardingType = "", string regardingName = "",
			string information = "", LogLevel level = LogLevel.Error)
			: this(message, exception, level, regardingType, regardingName, information)
		{
		}

		public LogEntry(string message, Exception exception, LogLevel level, string information)
			: this(message, exception, level, string.Empty, string.Empty, information)
		{
		}

		public LogEntry(string message, Exception exception, LogLevel level, string regardingType, string regardingName,
			string information)
		{
			Message = message;
			Level = level;
			Exception = exception;
			RegardingType = regardingType;
			RegardingName = regardingName;
			Information = information;
		}

		public LogEntry(string message, Exception exception, LogLevel level, string regardingType, string regardingName,
			string information, Guid userId) : this(message, exception, level, regardingType, regardingName, information)
		{
			UserId = userId;
		}

		#endregion

		#region Instance variables

		public Guid LogEntryId { get; } = Guid.NewGuid();

		public LogEntry ParentLogEntry
		{
			get; set;
		}

		public string Message
		{
			get; set;
		}

		public DateTime? StartDate
		{
			get; set;
		}

		public LogLevel Level
		{
			get; set;
		}

		public Guid UserId
		{
			get; set;
		}

		public string RegardingType
		{
			get; set;
		}

		public string RegardingName
		{
			get; set;
		}

		public Exception Exception
		{
			get; set;
		}

		public bool ExceptionThrown
		{
			get; set;
		}

		public string Assembly
		{
			get; set;
		}

		public string StackTrace
		{
			get; set;
		}

		public string CallingClass
		{
			get; set;
		}

		public string CallingFunction
		{
			get; set;
		}

		public int CallingLineNumber
		{
			get; set;
		}

		public string Information
		{
			get; set;
		}

		public int CurrentEntryIndex
		{
			get
			{
				return currentEntryIndex;
			}
			set
			{
				currentEntryIndex = value <= 0 ? 1 : value;
			}
		}

		public int ElapsedTime
		{
			get
			{
				return elapsedTime;
			}
			set
			{
				elapsedTime = elapsedTime < -1 ? -1 : value;
			}
		}

		#endregion
	}

	#endregion

	#region Plugin classes

	public enum PluginStage
	{
		All,
		PreValidation = 10,
		PreOperation = 20,
		PostOperation = 40
	}

	public enum PluginMode
	{
		Synchronous = 0,
		Asynchronous = 1,
		Both = 2
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public interface IPluginContext
	{
		IPlugin Plugin { get; }
		CodeActivity CodeActivity { get; }

		IServiceProvider ServiceProvider { get; }
		CodeActivityContext ExecutionContext { get; }

		IExecutionContext Context { get; }
		IOrganizationServiceFactory ServiceFactory { get; }
		ITracingService TracingService { get; }
		IOrganizationService Service { get; }

		string Message { get; }
		PluginStage Stage { get; }
		Guid UserId { get; }

		string Entity { get; }
		Guid Id { get; }

		CrmLog Log { get; }

		Entity PreImage { get; }
		Entity Target { get; }
		Entity PostImage { get; }
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public abstract class PluginLogic<TPlugin> : IPluginContext
		where TPlugin : IPlugin
	{
		public virtual IPlugin Plugin => plugin;
		public virtual CodeActivity CodeActivity => throw new NotSupportedException("Not supported in IPlugins.");
		public virtual CodeActivityContext ExecutionContext => throw new NotSupportedException("Not supported in IPlugins.");

		public virtual IServiceProvider ServiceProvider
		{
			get
			{
				serviceProvider.Require(nameof(serviceProvider));
				return serviceProvider;
			}
		}

		public virtual IExecutionContext Context => context
			?? (context = (IPluginExecutionContext)ServiceProvider.GetService(typeof(IPluginExecutionContext)));
		public virtual IOrganizationServiceFactory ServiceFactory => serviceFactory
			?? (serviceFactory = (IOrganizationServiceFactory)ServiceProvider.GetService(typeof(IOrganizationServiceFactory)));
		public virtual ITracingService TracingService => tracingService
			?? (tracingService = (ITracingService)ServiceProvider.GetService(typeof(ITracingService)));

		public virtual IOrganizationService Service => service ?? (service = ServiceFactory.CreateOrganizationService(UserId));

		public virtual string Message => Context.MessageName;
		public virtual PluginStage Stage => (PluginStage)((IPluginExecutionContext)Context).Stage;
		public virtual Guid UserId => userId ?? Context.UserId;

		public virtual string Entity => Context.PrimaryEntityName;
		public virtual Guid Id => Context.PrimaryEntityId;

		public virtual CrmLog Log => log;

		public virtual Entity PreImage => preImage ?? (preImage = GetPreImage<Entity>());
		public virtual Entity Target => target ?? (target = GetTarget<Entity>());
		public virtual Entity PostImage
		{
			get
			{
				try
				{
					return postImage ?? (postImage = GetPostImage<Entity>());
				}
				catch
				{
					try
					{
						return postImage ?? (postImage = BuildPostFromPreImage<Entity>());
					}
					catch
					{
						throw new InvalidPluginExecutionException("Missing a post-image for this step.");
					}
				}
			}
		}

		protected readonly string intendedPluginMessage;
		protected readonly PluginStage intendedPluginStage;
		protected readonly string intendedEntity;

		private TPlugin plugin;

		private IServiceProvider serviceProvider;
		private IPluginExecutionContext context;
		private IOrganizationServiceFactory serviceFactory;
		private ITracingService tracingService;
		private IOrganizationService service;

		private Guid? userId;

		private CrmLog log;

		private Entity preImage;
		private Entity target;
		private Entity postImage;

		protected PluginLogic(string intendedPluginMessage, PluginStage intendedPluginStage, string intendedEntity = null)
		{
			this.intendedPluginMessage = intendedPluginMessage;
			this.intendedPluginStage = intendedPluginStage;
			this.intendedEntity = intendedEntity;
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider)
		{
			Execute(plugin, serviceProvider, PluginUser.System);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, bool isLogEnabled)
		{
			Execute(plugin, serviceProvider, PluginUser.System, null, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, Guid? userId,
			bool isLogEnabled = true)
		{
			Execute(plugin, serviceProvider, PluginUser.Custom, userId, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, PluginUser user,
			bool isLogEnabled = true)
		{
			Execute(plugin, serviceProvider, user, null, isLogEnabled);
		}

		public virtual void Execute(TPlugin plugin, IServiceProvider serviceProvider, PluginUser user, Guid? userId,
			bool isLogEnabled = true)
		{
			this.plugin = plugin;
			this.serviceProvider = serviceProvider;
			this.userId = userId;

			InitialisePlugin(user);

			try
			{
				TracingService.Trace("Initialising log ...");
				log = new CrmLog(serviceProvider);
				TracingService.Trace("Finished initialising log.");

				if (isLogEnabled)
				{
					TracingService.Trace("Log enabled.");

					TracingService.Trace("Setting entry class in log ...");
					Log.SetEntryClass(typeof(TPlugin).FullName);

					TracingService.Trace("Checking regarding to be set in log ...");

					if (Context.PrimaryEntityName != null && Context.PrimaryEntityName != "none"
						&& Context.PrimaryEntityId != Guid.Empty)
					{
						TracingService.Trace("Setting regarding in log ...");
						Log.SetRegarding(Context.PrimaryEntityName, Context.PrimaryEntityId);
					}
				}
			}
			catch (Exception ex)
			{
				throw new InvalidPluginExecutionException("Failed to init log => " + ex.Message, ex);
			}

			try
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution start ...");
					Log.LogExecutionStart();
				}

				TracingService.Trace("Executing plugin logic ...");
				ExecuteLogic();
				TracingService.Trace("Finished executing plugin logic.");
			}
			catch (Exception ex)
			{
				TracingService.Trace($"Exception occurred: {ex.Message}.");
				TracingService.Trace("Logging exception ...");

				if (isLogEnabled)
				{
					Log.ExecutionFailed();
					Log.Log(ex, Context);
				}
				else
				{
					TracingService.Trace(ex.ToString());
					TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				}

				throw new InvalidPluginExecutionException(ex.Message, ex);
			}
			finally
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution end ...");

					try
					{
						Log.LogExecutionEnd();
					}
					catch (Exception e)
					{
						TracingService.Trace(e.ToString());
						TracingService.Trace(CrmHelpers.BuildExceptionMessage(e));
						throw;
					}
				}

				TracingService.Trace("Finished executing plugin.");
			}
		}

		protected abstract void ExecuteLogic();

		protected TEntity GetPreImage<TEntity>() where TEntity : Entity
		{
			var image = Context.PreEntityImages.FirstOrDefault().Value;

			if (image == null)
			{
				throw new InvalidPluginExecutionException("Missing a pre-image for this step.");
			}

			return image.ToEntity<TEntity>();
		}

		protected TEntity GetTarget<TEntity>() where TEntity : Entity
		{
			if (Context.InputParameters.TryGetValue("Target", out var target) && target is Entity targetEntity)
			{
				return targetEntity.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing Target in the plugin input, or not of type Entity.");
		}

		protected EntityReference GetTargetReference()
		{
			if (Context.InputParameters.TryGetValue("Target", out var target) && target is EntityReference targetEntityRef)
			{
				return targetEntityRef;
			}

			throw new InvalidPluginExecutionException("Missing Target in the plugin input, or not of type EntityReference.");
		}

		protected TEntity BuildPostFromPreImage<TEntity>() where TEntity : Entity
		{
			var preImage = GetPreImage<TEntity>();
			var target = GetTarget<TEntity>();
			var postImage = new Entity(target.LogicalName, target.Id);

			foreach (var pair in preImage.Attributes)
			{
				postImage[pair.Key] = pair.Value;
			}

			foreach (var pair in preImage.FormattedValues)
			{
				postImage.FormattedValues[pair.Key] = pair.Value;
			}

			foreach (var pair in target.Attributes)
			{
				postImage[pair.Key] = pair.Value;
			}

			foreach (var pair in target.FormattedValues)
			{
				postImage.FormattedValues[pair.Key] = pair.Value;
			}

			return postImage.ToEntity<TEntity>();
		}

		protected TEntity GetPostImage<TEntity>() where TEntity : Entity
		{
			var image = Context.PostEntityImages.FirstOrDefault().Value;

			if (image == null)
			{
				throw new InvalidPluginExecutionException("Missing a post-image for this step.");
			}

			return image.ToEntity<TEntity>();
		}

		protected virtual bool IsContextValid()
		{
			return true;
		}

		protected virtual void ValidateRegistration()
		{
			if (!string.IsNullOrWhiteSpace(intendedEntity) && Context.PrimaryEntityName != intendedEntity)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong entity: {Context.PrimaryEntityName}, "
						+ $"expected: {intendedEntity}");
			}

			if (!string.IsNullOrWhiteSpace(intendedPluginMessage) && Context.MessageName != intendedPluginMessage)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong message: {Context.MessageName}, "
						+ $"expected: {intendedPluginMessage}.");
			}

			var pluginContext = (IPluginExecutionContext)Context;

			if (intendedPluginStage != PluginStage.All && pluginContext.Stage != (int)intendedPluginStage)
			{
				throw new InvalidPluginExecutionException(
					$"Step registered on wrong stage: {pluginContext.Stage}, "
						+ $"expected: {intendedPluginStage}");
			}
		}

		protected void InitialisePlugin(PluginUser user = PluginUser.System)
		{
			tracingService = (ITracingService)ServiceProvider.GetService(typeof(ITracingService));

			TracingService.Trace("Getting context ...");
			context = (IPluginExecutionContext)ServiceProvider.GetService(typeof(IPluginExecutionContext));
			ValidateRegistration();

			TracingService.Trace("Getting factory ...");
			serviceFactory = (IOrganizationServiceFactory)ServiceProvider.GetService(typeof(IOrganizationServiceFactory));

			switch (user)
			{
				case PluginUser.ContextUser:
					TracingService.Trace("Running as ContextUser.");
					userId = Context.UserId;
					break;

				case PluginUser.InitiatingUser:
					TracingService.Trace("Running as InitiatingUserId.");
					userId = Context.InitiatingUserId;
					break;

				case PluginUser.System:
					TracingService.Trace("Running as System.");
					userId = null;
					break;

				case PluginUser.Custom:
					TracingService.Trace($"Running as {userId}.");
					break;

				default:
					throw new ArgumentOutOfRangeException("user", user, "Plugin user type is out of range.");
			}

			TracingService.Trace("Getting service ...");
			service = ServiceFactory.CreateOrganizationService(userId);

			if (!IsContextValid())
			{
				throw new InvalidPluginExecutionException("Failed to initialise plugin due to invalid context.");
			}

			TracingService.Trace($"Initialised plugin.");
		}
	}

	/// <summary>
	///     Author: Ahmed Elsawalhy
	/// </summary>
	[GeneratedCode("Not generated code, but used to exclude from Code Analysis.", "0.0.0.0")]
	public abstract class StepLogic<TCodeActivity> : IPluginContext
		where TCodeActivity : CodeActivity
	{
		public virtual IPlugin Plugin => throw new NotSupportedException("Not supported in Code Activities.");
		public virtual CodeActivity CodeActivity => codeActivity;

		public virtual IServiceProvider ServiceProvider => throw new NotSupportedException("Not supported in Code Activities.");

		public virtual CodeActivityContext ExecutionContext
		{
			get
			{
				executionContext.Require(nameof(executionContext));
				return executionContext;
			}
		}

		public virtual IExecutionContext Context => context ?? (context = ExecutionContext.GetExtension<IWorkflowContext>());
		public virtual IOrganizationServiceFactory ServiceFactory => serviceFactory
			?? (serviceFactory = ExecutionContext.GetExtension<IOrganizationServiceFactory>());
		public virtual ITracingService TracingService => tracingService
			?? (tracingService = ExecutionContext.GetExtension<ITracingService>());

		public virtual IOrganizationService Service => service ?? (service = ServiceFactory.CreateOrganizationService(UserId));

		public virtual string Message => Context.MessageName;
		public virtual PluginStage Stage => throw new NotSupportedException("Not supported in Code Activities.");
		public virtual Guid UserId => userId ?? Context.UserId;

		public virtual string Entity => Context.PrimaryEntityName;
		public virtual Guid Id => Context.PrimaryEntityId;

		public virtual CrmLog Log => log;

		public virtual Entity PreImage => preImage ?? (preImage = GetPreImage<Entity>());
		public virtual Entity Target => target ?? (target = GetTarget<Entity>());
		public virtual Entity PostImage
		{
			get
			{
				try
				{
					return postImage ?? (postImage = GetPostImage<Entity>(true));
				}
				catch
				{
					throw new InvalidPluginExecutionException("Missing a post-image for this step.");
				}
			}
		}

		protected TCodeActivity codeActivity;

		private CodeActivityContext executionContext;
		private IWorkflowContext context;
		private IOrganizationServiceFactory serviceFactory;
		private ITracingService tracingService;
		private IOrganizationService service;

		private Guid? userId;

		private CrmLog log;

		private Entity preImage;
		private Entity target;
		private Entity postImage;

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext)
		{
			Execute(codeActivity, executionContext, PluginUser.System);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			bool isLogEnabled)
		{
			Execute(codeActivity, executionContext, PluginUser.System, null, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			Guid? userId, bool isLogEnabled = true)
		{
			Execute(codeActivity, executionContext, PluginUser.Custom, userId, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			PluginUser user, bool isLogEnabled = true)
		{
			Execute(codeActivity, executionContext, user, null, isLogEnabled);
		}

		public virtual void Execute(TCodeActivity codeActivity, CodeActivityContext executionContext,
			PluginUser user, Guid? userId, bool isLogEnabled = true)
		{
			this.codeActivity = codeActivity;
			this.executionContext = executionContext;
			this.userId = userId;

			InitialiseCodeActivity(user);

			try
			{
				TracingService.Trace("Initialising Log ...");
				log = new CrmLog(ExecutionContext);
				TracingService.Trace("Finished initialising Log.");

				if (isLogEnabled)
				{
					TracingService.Trace("Log enabled.");

					TracingService.Trace("Setting entry class in Log ...");
					Log.SetEntryClass(typeof(TCodeActivity).FullName);

					TracingService.Trace("Checking regarding to be set in Log ...");
					if (Context.PrimaryEntityName != null && Context.PrimaryEntityName != "none"
						&& Context.PrimaryEntityId != Guid.Empty)
					{
						TracingService.Trace("Setting regarding in Log ...");
						Log.SetRegarding(Context.PrimaryEntityName, Context.PrimaryEntityId);
					}
				}
			}
			catch (Exception ex)
			{
				throw new InvalidPluginExecutionException("Failed to init Log => " + ex.Message, ex);
			}

			try
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution start ...");
					Log.LogExecutionStart();
				}

				TracingService.Trace("Executing step logic ...");
				ExecuteLogic();
				TracingService.Trace("Finished executing step.");
			}
			catch (Exception ex)
			{
				TracingService.Trace($"Exception occurred: {ex.Message}.");
				TracingService.Trace("Logging exception ...");

				if (isLogEnabled)
				{
					Log.ExecutionFailed();
					Log.Log(ex, Context);
				}
				else
				{
					TracingService.Trace(ex.ToString());
					TracingService.Trace(CrmHelpers.BuildExceptionMessage(ex));
				}

				throw new InvalidPluginExecutionException(ex.Message, ex);
			}
			finally
			{
				if (isLogEnabled)
				{
					TracingService.Trace("Logging execution end ...");

					try
					{
						Log.LogExecutionEnd();
					}
					catch (Exception e)
					{
						TracingService.Trace(e.ToString());
						TracingService.Trace(CrmHelpers.BuildExceptionMessage(e));
						throw;
					}
				}

				TracingService.Trace("Finished executing step.");
			}
		}

		protected abstract void ExecuteLogic();

		protected TEntity GetPreImage<TEntity>() where TEntity : Entity
		{
			if (Context.PreEntityImages.TryGetValue("PreBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a pre-image for this step.");
		}

		protected TEntity GetTarget<TEntity>() where TEntity : Entity
		{
			throw new InvalidPluginExecutionException("The Target parameter should not be accessed in a step.");
		}

		protected TEntity GetPostImage<TEntity>(bool retrieveIfMissing = false, ColumnSet columns = null) where TEntity : Entity
		{
			if (Context.PostEntityImages.TryGetValue("PostBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			if (retrieveIfMissing)
			{
				return service.Retrieve(Context.PrimaryEntityName, Context.PrimaryEntityId, columns == null ? new ColumnSet(true) : columns)
					.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a post-image for this step.");
		}

		protected TEntity GetPostPreImage<TEntity>(bool retrieveIfMissing = false, ColumnSet columns = null) where TEntity : Entity
		{
			if (Context.PostEntityImages.TryGetValue("PostBusinessEntity", out var image))
			{
				return image.ToEntity<TEntity>();
			}

			if (Context.PreEntityImages.TryGetValue("PreBusinessEntity", out image))
			{
				return image.ToEntity<TEntity>();
			}

			if (retrieveIfMissing)
			{
				return service.Retrieve(Context.PrimaryEntityName, Context.PrimaryEntityId, columns == null ? new ColumnSet(true) : columns)
					.ToEntity<TEntity>();
			}

			throw new InvalidPluginExecutionException("Missing a post or pre-image for this step.");
		}

		protected virtual bool IsContextValid()
		{
			return true;
		}

		protected void InitialiseCodeActivity(PluginUser user = PluginUser.System)
		{
			tracingService = ExecutionContext.GetExtension<ITracingService>();
			context = ExecutionContext.GetExtension<IWorkflowContext>();
			TracingService.Trace("Got context.");
			serviceFactory = ExecutionContext.GetExtension<IOrganizationServiceFactory>();
			TracingService.Trace("Got factory.");

			switch (user)
			{
				case PluginUser.ContextUser:
					userId = context.UserId;
					TracingService.Trace("Running as ContextUser.");
					break;

				case PluginUser.InitiatingUser:
					userId = context.InitiatingUserId;
					TracingService.Trace("Running as InitiatingUserId.");
					break;

				case PluginUser.System:
					userId = null;
					TracingService.Trace("Running as System.");
					break;

				case PluginUser.Custom:
					TracingService.Trace($"Running as {userId}.");
					break;

				default:
					throw new ArgumentOutOfRangeException("user", user, "Step user type is out of range.");
			}

			service = ServiceFactory.CreateOrganizationService(userId);
			TracingService.Trace("Got service.");

			if (!IsContextValid())
			{
				throw new InvalidPluginExecutionException("Failed to initialise workflow step due to invalid context.");
			}

			TracingService.Trace($"Initialised step.");
		}
	}

	#endregion
}
